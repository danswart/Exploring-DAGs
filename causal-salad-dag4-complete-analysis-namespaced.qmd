---
title: "DAG Analysis: Mimic Experimental Causal Structure with Synthetic Data"
subtitle: ""
description: ""
author: 
  - name: "Dan Swart, CPA (ret)"
    affiliations:
      - "SCUC-ISD Board of Trustees"
      - "Seat 6"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 14pt
    mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: false
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: false
    error: false
    warning: false
    message: false
    cache: false

---


```{r}
#| label: setup
#| include: false

# install.packages(base::c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# # load libraries



# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Options
base::options(scipen = 999)
base::options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
base::options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
base::options(qic.signalcol = "red") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
base::options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
base::options(DT.options = base::list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
base::options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
base::options(tigris_use_cache = TRUE)


flextable::set_flextable_defaults(
  font.size = 14, 
  font.family = "Cabin",
  font.color = "black",
  table.layout = "fixed",
  border.color = "darkgray",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4,
  line_spacing = 1.3,
  digits = 2,
  decimal.mark = ",",
  big.mark = " ",
  na_str = "<na>"
  )


# Set global theme for consistent plots
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 20) + 
                   ggplot2::theme(plot.title = ggplot2::element_text(face = "bold",
                                                                      size = 26),
                                  plot.subtitle = ggplot2::element_text(face = "bold",
                                                                         size = 24),
                                  axis.title.x = ggplot2::element_text(face = "bold",
                                                                        size = 22),
                                  axis.title.y = ggplot2::element_text(face = "bold",
                                                                        size = 22),
                                  axis.text.x = ggplot2::element_text(face = "bold",
                                                                       size = 22,
                                                                       angle = 45,
                                                                       hjust = 1),
                                  legend.position = "bottom",
                                  strip.text = ggplot2::element_text(face = "bold"),
                                  panel.spacing.x = grid::unit(1.5,
                                                                "cm"),
                                  panel.spacing.y = grid::unit(1.5,
                                                                "cm"),
                                  plot.margin = ggplot2::margin(20,
                                                                 20,
                                                                 20,
                                                                 20,
                                                                 "pt")))


# Set seed for reproducibility
base::set.seed(123)

```



## 1. Introduction: Understanding Experimental Causal Structures

This document explores an experimental causal structure represented by a directed acyclic graph (DAG). A randomized controlled trial or experimental design represents the gold standard of causal inference where:

- X is an experimentally manipulated exposure variable (treatment/intervention)
- Y is the outcome variable of interest
- Z, C, and B are other variables that affect the outcome but are unrelated to the treatment assignment
- A affects both Z and B, representing a root cause in the system

The structure reflects an ideal experimental scenario where the exposure X is randomly assigned, eliminating confounding between X and Y. This design allows for unbiased estimation of the causal effect without adjustment for confounding variables.

## 2. Describe the DAG in words

This DAG represents an experimental causal structure with six variables:

- X: The experimentally manipulated exposure/treatment variable
- Y: The outcome variable
- Z: A variable that affects Y directly but is unrelated to X (potential prognostic factor)
- C: Another variable that affects Y directly but is unrelated to X (potential prognostic factor)  
- A: A root cause variable that affects Z
- B: A variable that affects both Z and Y directly

The key feature of this experimental structure is that X has no incoming arrows, meaning it is independent of all other variables in the system. This represents the fundamental principle of randomization in experimental design.

The causal relationships include:
1. A direct effect from X to Y (the causal effect of interest)
2. Independent effects of Z, C, and B on Y
3. A affects Z (creating a pathway A → Z → Y)
4. B affects both Z and Y (creating pathways B → Z → Y and B → Y)

In a real-world context, this could represent:
- X: Randomly assigned medication treatment
- Y: Patient recovery outcome
- Z: Patient education level
- C: Insurance coverage quality
- A: Socioeconomic status
- B: Disease severity at baseline

The beauty of this experimental structure is that no adjustment is necessary to identify the causal effect of X on Y. The randomization of X breaks all potential confounding pathways, allowing the simple association between X and Y to represent the true causal effect.

## 3. Recreate the DAG for reference using DiagrammeR and ggdag

```{r}
#| label: diagrammer-visualization
#| fig-cap: "Directed Acyclic Graph of Experimental Causal Structure"


# library(DiagrammeR)

# Create the DAG using DiagrammeR for detailed control
experimental_dag_viz <- DiagrammeR::grViz("
  digraph DAG {
    # Graph settings
    graph [layout=neato, margin=\"0.0, 0.0, 0.0, 0.0\"]
    
    # Add a title
    labelloc=\"t\"
    label=\"Experimental Causal Structure\\nRandomized Assignment Design\\n   \"
    fontname=\"Cabin\"  fontsize=18
    
   # Node settings
    node [shape=plaintext, fontsize=20, fontname=\"Cabin\"]
    
    # Edge settings
    edge [penwidth=1.20, color=\"darkblue\", arrowsize=1.00, fontsize=12]
    
    
    # Nodes with exact coordinates
    X [label=\"X (Exposure)\", pos=\"1.0, 3.0!\", fontcolor=\"navy\"]
    Y [label=\"Y (Outcome)\", pos=\"5.0, 3.0!\", fontcolor=\"navy\"]
    Z [label=\"Z\", pos=\"3.0, 5.0!\", fontcolor=\"firebrick\"]
    C [label=\"C\", pos=\"3.0, 1.0!\", fontcolor=\"darkgreen\"]
    A [label=\"A\", pos=\"1.0, 5.0!\", fontcolor=\"darkgreen\"]
    B [label=\"B\", pos=\"5.0, 5.0!\", fontcolor=\"purple\"]
    
    # Edges with coefficients from the synthetic data
    X -> Y [label=\"0.4\"]
    Z -> Y [label=\"0.25\"]
    C -> Y [label=\"0.2\"]
    B -> Y [label=\"0.15\"]
    A -> Z [label=\"0.3\"]
    B -> Z [label=\"0.2\"]
    
    # Caption
    Caption [shape=plaintext, label=\"Figure 1: Experimental Structure - No Confounding\", 
             fontsize=12, pos=\"2,0.0!\"]
  }
")

# Show the DiagrammeR DAG
experimental_dag_viz
```

```{r}
#| label: ggdag-visualization
#| fig-cap: "ggdag representation of the experimental causal model"

# Define the DAG using dagitty/ggdag for analysis
experimental_dag <- ggdag::dagify(
  Y ~ X + Z + C + B,
  Z ~ A + B,
  exposure = "X",
  outcome = "Y",
  labels = base::c("X" = "X (Exposure)", 
             "Y" = "Y (Outcome)", 
             "Z" = "Z",
             "C" = "C",
             "A" = "A",
             "B" = "B")
)

# Set coordinates for nice visualization
dagitty::coordinates(experimental_dag) <- base::list(
  x = base::c(X = 1, Y = 3, Z = 2, C = 2, A = 1, B = 3),
  y = base::c(X = 2, Y = 2, Z = 3, C = 1, A = 3, B = 3)
) 


# Create nice visualization with ggdag
ggdag::ggdag(experimental_dag, edge_type = "link") + 
  ggdag::geom_dag_point(color = "lightblue", size = 14, alpha = 0.7) +
  ggdag::geom_dag_text(color = "black") +
  ggdag::geom_dag_edges(edge_colour = "blue", edge_width = 1.0, arrow_size = 0.6) +
  ggdag::theme_dag() +
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ggtitle("DAG: Experimental Causal Structure")
```

## 4. Generate synthetic data following the causal structure

We'll generate synthetic data following the experimental causal relationships. The key feature is that X is generated independently (representing randomization), while other variables follow their causal relationships.

```{r}
#| label: generate-synthetic-data
#| tbl-cap: "Summary of the synthetic experimental data"

# Set seed for reproducibility
base::set.seed(42)

# Sample size
n <- 1000

# Generate the data following the experimental DAG structure
# Starting with exogenous variables (A, C, and the randomized X)
A <- base::round(stats::rnorm(n, mean = 0, sd = 1), 3)
C <- base::round(stats::rnorm(n, mean = 0, sd = 1), 3)

# X is randomly assigned (independent of all other variables)
X <- base::round(stats::rnorm(n, mean = 0, sd = 1), 3)

# Generate B as exogenous
B <- base::round(stats::rnorm(n, mean = 0, sd = 1), 3)

# Generate Z as influenced by A and B
Z <- base::round(0.3 * A + 0.2 * B + stats::rnorm(n, mean = 0, sd = 0.8), 3)

# Generate Y as influenced by X, Z, C, and B
Y <- base::round(0.4 * X + 0.25 * Z + 0.2 * C + 0.15 * B + stats::rnorm(n, mean = 0, sd = 0.6), 3)

# True direct effect of X on Y is 0.4
true_direct_effect <- 0.400

# Create a data frame
dag_data <- base::data.frame(A, B, Z, C, X, Y)


# Get numeric summary statistics rounded to 3 decimal places
base::round(base::sapply(dag_data, summary), 3)
```

```{r}
#| label: true-effects-table
#| tbl-cap: "True causal effects in the experimental DAG structure"

# Create a table of true effects
true_effects <- base::data.frame(
  Relationship = base::c("A → Z", "B → Z", "B → Y", "Z → Y", "C → Y", "X → Y"),
  Effect = base::c(0.3, 0.2, 0.15, 0.25, 0.2, 0.4),
  Type = base::c("Root cause → Prognostic factor", "Independent cause → Prognostic factor", 
           "Independent cause → Outcome", "Prognostic factor → Outcome", 
           "Independent cause → Outcome", "Exposure → Outcome (CAUSAL EFFECT)")
)

# Display the table
DT::datatable(true_effects,
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

## 5. Examine structure of synthetic data

### 5.1 Correlation matrix of synthetic experimental data

```{r}
#| label: correlation-analysis
#| fig-cap: "Correlation matrix of synthetic experimental data variables"

# Calculate correlation matrix
corr_matrix <- stats::cor(dag_data)

# Create correlation table
corr_table <- base::data.frame(base::round(corr_matrix, 3))

# Display correlation table
DT::datatable(corr_table,
          options = base::list(pageLength = 10, dom = 't'),
          rownames = TRUE,
          class = 'cell-border stripe compact responsive')

# Correlation plot
corrplot::corrplot(corr_matrix, 
         method = "color", 
         type = "upper", 
         order = "hclust",
         addCoef.col = "black",
         number.cex = 1.5,  # This controls the size of the numbers
         tl.col = "black",
         tl.srt = 45,
         diag = FALSE,
         col = grDevices::colorRampPalette(base::c("#6BAED6", "white", "#E6550D"))(200),
         title = "Correlation Matrix of Variables",
         mar = base::c(0,0,1,0))

# Add a description of the correlation levels
corr_description <- base::data.frame(
  Variables = base::c("X and Y", "X and Z", "X and C", "X and A", "X and B",
                "Y and Z", "Y and C", "Y and B", "Y and A"),
  Correlation = base::c(base::round(stats::cor(X, Y), 3), base::round(stats::cor(X, Z), 3), base::round(stats::cor(X, C), 3), 
                  base::round(stats::cor(X, A), 3), base::round(stats::cor(X, B), 3), base::round(stats::cor(Y, Z), 3), 
                  base::round(stats::cor(Y, C), 3), base::round(stats::cor(Y, B), 3), base::round(stats::cor(Y, A), 3)),
  Interpretation = base::c(
    "Moderate positive correlation due to direct causal effect (unconfounded)",
    "Very weak correlation due to randomization of X (independence)",
    "Very weak correlation due to randomization of X (independence)",
    "Very weak correlation due to randomization of X (independence)",
    "Very weak correlation due to randomization of X (independence)",
    "Moderate positive correlation due to Z causing Y",
    "Weak positive correlation due to C causing Y",
    "Moderate positive correlation due to B causing Y",
    "Weak positive correlation due to indirect path A → Z → Y"
  )
)

# Display the correlation description
DT::datatable(corr_description,
          caption = "Interpretation of key correlations in the experimental DAG structure",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

## 6. Visualize distributions and relationships in synthetic data

```{r}
#| label: visualize-distributions
#| fig-cap: "Distributions of all variables in the synthetic experimental data"

# Visualize distributions of all variables
dag_data |>
  tidyr::pivot_longer(cols = tidyr::everything(), names_to = "Variable", values_to = "Value") |>
  ggplot2::ggplot(ggplot2::aes(x = Value)) +
  ggplot2::geom_histogram(fill = "steelblue", alpha = 0.7, bins = 30) +
  ggplot2::facet_wrap(~ Variable, scales = "free") +
  ggplot2::theme_minimal() +
  ggplot2::ggtitle("Distributions of Variables in Experimental Data")
```

```{r}
#| label: visualize-relationships
#| fig-cap: "Scatterplots showing key relationships in the experimental DAG"
#| fig-subcap: 
#|   - "Relationship between X and Y (Direct Causal Effect)"
#|   - "Relationship between Z and Y"
#|   - "Relationship between C and Y"
#|   - "Relationship between B and Y"
#| layout-ncol: 2

# X vs Y scatterplot (the causal relationship of interest)
ggplot2::ggplot(dag_data, ggplot2::aes(x = X, y = Y)) +
   ggplot2::geom_point(alpha = 0.3, color = "navy") +
   ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "darkred") +
   ggplot2::theme_minimal() +
  ggplot2::ggtitle("X → Y: Direct Causal Effect (Unconfounded)") +
   ggplot2::theme(plot.title = ggplot2::element_text(size = 28))

# Z vs Y scatterplot
ggplot2::ggplot(dag_data, 
                ggplot2::aes(x = Z, y = Y)) +
   ggplot2::geom_point(alpha = 0.3, color = "darkgreen") +
   ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "darkred") +
   ggplot2::theme_minimal() +
  ggplot2::ggtitle("Z → Y: Prognostic Factor Effect") +
   ggplot2::theme(plot.title = ggplot2::element_text(size = 28))

# C vs Y scatterplot
ggplot2::ggplot(dag_data, 
                ggplot2::aes(x = C, y = Y)) +
   ggplot2::geom_point(alpha = 0.3, color = "purple") +
   ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "darkred") +
   ggplot2::theme_minimal() +
  ggplot2::ggtitle("C → Y: Independent Predictor Effect") +
   ggplot2::theme(plot.title = ggplot2::element_text(size = 28))

# B vs Y scatterplot
ggplot2::ggplot(dag_data, 
                ggplot2::aes(x = B, y = Y)) +
   ggplot2::geom_point(alpha = 0.3, color = "orange") +
   ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "darkred") +
   ggplot2::theme_minimal() +
  ggplot2::ggtitle("B → Y: Direct Effect") +
   ggplot2::theme(plot.title = ggplot2::element_text(size = 28))
```

## 7. Residual Diagnostics

Let's examine the residuals to ensure the model assumptions are met for the experimental design.

```{r}
#| label: model-residuals
#| fig-cap: "Residual diagnostics for the experimental model"

# Create models with different approaches
models <- base::list(
  "Unadjusted (Correct for Experimental Design)" = stats::lm(Y ~ X, data = dag_data),
  "Adjusted for Z" = stats::lm(Y ~ X + Z, data = dag_data),
  "Adjusted for C" = stats::lm(Y ~ X + C, data = dag_data),
  "Adjusted for Z, C" = stats::lm(Y ~ X + Z + C, data = dag_data),
  "Adjusted for B" = stats::lm(Y ~ X + B, data = dag_data),
  "All variables" = stats::lm(Y ~ X + Z + C + A + B, data = dag_data)
)

# Get the correct model for experimental design (unadjusted)
correct_model <- models[["Unadjusted (Correct for Experimental Design)"]]

# Plot diagnostics
par(mfrow = base::c(2, 2))
plot(correct_model)
```

The residual plots for the experimental model (simple regression of Y on X) show:

1. **Residuals vs Fitted**: Points are randomly scattered around zero with no clear pattern, supporting the linear relationship assumption.

2. **Normal Q-Q**: Points follow the diagonal line closely, indicating approximately normal residuals.

3. **Scale-Location**: No clear pattern in the variance, supporting homoscedasticity.

4. **Residuals vs Leverage**: No influential outliers detected.

These diagnostics confirm that the simple linear model is appropriate for the experimental data.

## 8. Test the Structure by comparing models with and without adjustment

### 8.1 Unadjusted Model (Correct for Experimental Design)

```{r}
#| label: unadjusted-model
#| tbl-cap: "Results of the unadjusted model (correct for experimental design)"

# Fit unadjusted model (correct for experimental design)
model_unadjusted <- stats::lm(Y ~ X, data = dag_data)

# Display model summary
summary_unadj <- base::summary(model_unadjusted)

# Extract the coefficient for X
coef_unadjusted <- stats::coef(model_unadjusted)["X"]

# Create a data frame for the table
unadj_results <- base::data.frame(
  Term = base::c("Intercept", "X (Exposure)"),
  Estimate = base::c(stats::coef(model_unadjusted)[1], stats::coef(model_unadjusted)[2]),
  StdError = base::c(summary_unadj$coefficients[1,2], summary_unadj$coefficients[2,2]),
  tValue = base::c(summary_unadj$coefficients[1,3], summary_unadj$coefficients[2,3]),
  pValue = base::c(summary_unadj$coefficients[1,4], summary_unadj$coefficients[2,4])
)

# Display the results
DT::datatable(unadj_results,
          caption = "Unadjusted Model Results (Correct for Experimental Design)",
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE) |>
  DT::formatRound(columns=base::c('Estimate', 'StdError', 'tValue'), digits=3) |>
  DT::formatSignif(columns='pValue', digits=3)
```

### 8.2 Adjusted Model for Precision (Optional in Experimental Design)

```{r}
#| label: adjusted-model-precision
#| tbl-cap: "Results of adjusted model for increased precision"

# Fit adjusted model for precision (adjusting for prognostic factors)
model_adjusted_precision <- stats::lm(Y ~ X + Z + C + B, data = dag_data)

# Display model summary
summary_adj_precision <- base::summary(model_adjusted_precision)

# Extract the coefficient for X
coef_adjusted_precision <- stats::coef(model_adjusted_precision)["X"]

# Create a data frame for the table
adj_precision_results <- base::data.frame(
  Term = base::c("Intercept", "X (Exposure)", "Z", "C", "B"),
  Estimate = stats::coef(model_adjusted_precision),
  StdError = summary_adj_precision$coefficients[,2],
  tValue = summary_adj_precision$coefficients[,3],
  pValue = summary_adj_precision$coefficients[,4]
)

# Display the results
DT::datatable(adj_precision_results,
          caption = "Adjusted Model Results (For Increased Precision)",
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE) |>
  DT::formatRound(columns=base::c('Estimate', 'StdError', 'tValue'), digits=3) |>
  DT::formatSignif(columns='pValue', digits=3)

# Show R-squared
r2_adj_precision <- base::data.frame(
  Measure = base::c("R-squared", "Adjusted R-squared"),
  Value = base::c(summary_adj_precision$r.squared, summary_adj_precision$adj.r.squared)
)

DT::datatable(r2_adj_precision,
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE) |>
  DT::formatRound(columns='Value', digits=3)
```

## 9. Comparing Model Results

```{r}
#| label: model-comparison
#| tbl-cap: "Comparison of different modeling strategies for experimental data"

# True effect of X on Y
true_effect <- 0.400

# Create a comparison table for all models
comparison_df <- base::data.frame(
  Model = base::c("True Causal Effect",
           "Unadjusted (Correct for RCT)", 
           "Adjusted for Z (Prognostic)", 
           "Adjusted for C (Prognostic)",
           "Adjusted for B (Prognostic)",
           "Adjusted for Z, C (Multiple Prognostic)",
           "Adjusted for All Variables"),
  Coefficient = base::c(
    true_effect,
    stats::coef(models[["Unadjusted (Correct for Experimental Design)"]])["X"],
    stats::coef(models[["Adjusted for Z"]])["X"],
    stats::coef(models[["Adjusted for C"]])["X"],
    stats::coef(models[["Adjusted for B"]])["X"],
    stats::coef(models[["Adjusted for Z, C"]])["X"],
    stats::coef(models[["All variables"]])["X"]
  ),
  StandardError = base::c(
    NA,
    base::summary(models[["Unadjusted (Correct for Experimental Design)"]])$coefficients["X", "Std. Error"],
    base::summary(models[["Adjusted for Z"]])$coefficients["X", "Std. Error"],
    base::summary(models[["Adjusted for C"]])$coefficients["X", "Std. Error"],
    base::summary(models[["Adjusted for B"]])$coefficients["X", "Std. Error"],
    base::summary(models[["Adjusted for Z, C"]])$coefficients["X", "Std. Error"],
    base::summary(models[["All variables"]])$coefficients["X", "Std. Error"]
  )
)

# Calculate error and bias
comparison_df$Error <- comparison_df$Coefficient - true_effect
comparison_df$BiasPercent <- 100 * (comparison_df$Coefficient - true_effect) / true_effect

# Add R-squared values
comparison_df$R2 <- base::c(
  NA,
  base::summary(models[["Unadjusted (Correct for Experimental Design)"]])$r.squared,
  base::summary(models[["Adjusted for Z"]])$r.squared,
  base::summary(models[["Adjusted for C"]])$r.squared,
  base::summary(models[["Adjusted for B"]])$r.squared,
  base::summary(models[["Adjusted for Z, C"]])$r.squared,
  base::summary(models[["All variables"]])$r.squared
)

# Format for display (changed to 3 decimal places)
comparison_df$Coefficient <- base::round(comparison_df$Coefficient, 3)
comparison_df$StandardError <- base::round(comparison_df$StandardError, 3)
comparison_df$Error <- base::round(comparison_df$Error, 3)
comparison_df$BiasPercent <- base::round(comparison_df$BiasPercent, 3)
comparison_df$R2 <- base::round(comparison_df$R2, 3)

# Display as a table
DT::datatable(comparison_df,
          caption = "Comparison of Different Modeling Strategies for Experimental Data",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')

```

## 10. Statistical tests for differences between models

```{r}
#| label: statistical-tests-diffs
#| tbl-cap: "Statistical tests for model performance in experimental design"

# Compare models using anova and tests against true effect
model_comparison_unadj_z <- stats::anova(models[["Unadjusted (Correct for Experimental Design)"]], models[["Adjusted for Z"]])
model_comparison_unadj_zc <- stats::anova(models[["Unadjusted (Correct for Experimental Design)"]], models[["Adjusted for Z, C"]])
model_comparison_unadj_all <- stats::anova(models[["Unadjusted (Correct for Experimental Design)"]], models[["All variables"]])

# Test if unadjusted coefficient differs from true effect
unadj_z_stat <- (stats::coef(models[["Unadjusted (Correct for Experimental Design)"]])["X"] - true_effect) / 
  base::summary(models[["Unadjusted (Correct for Experimental Design)"]])$coefficients["X", "Std. Error"]
unadj_p_value <- 2 * (1 - stats::pnorm(base::abs(unadj_z_stat)))

# Test if adjusted coefficient (Z) differs from true effect
adj_z_z_stat <- (stats::coef(models[["Adjusted for Z"]])["X"] - true_effect) / 
  base::summary(models[["Adjusted for Z"]])$coefficients["X", "Std. Error"]
adj_z_p_value <- 2 * (1 - stats::pnorm(base::abs(adj_z_z_stat)))

# Test if adjusted coefficient (Z, C) differs from true effect
adj_zc_z_stat <- (stats::coef(models[["Adjusted for Z, C"]])["X"] - true_effect) / 
  base::summary(models[["Adjusted for Z, C"]])$coefficients["X", "Std. Error"]
adj_zc_p_value <- 2 * (1 - stats::pnorm(base::abs(adj_zc_z_stat)))

# Create a data frame for the results
significance_df <- base::data.frame(
  Comparison = base::c(
    "Unadjusted vs. Adjusted for Z",
    "Unadjusted vs. Adjusted for Z, C",
    "Unadjusted vs. Full Model",
    "Unadjusted Model vs. True Effect",
    "Adjusted (Z) Model vs. True Effect", 
    "Adjusted (Z, C) Model vs. True Effect"
  ),
  
  Test = base::c(
    "F-test (ANOVA)",
    "F-test (ANOVA)",
    "F-test (ANOVA)",
    "Z-test (coefficient vs. true effect)",
    "Z-test (coefficient vs. true effect)",
    "Z-test (coefficient vs. true effect)"
  ),
  
  Statistic = base::c(
    base::round(model_comparison_unadj_z$F[2], 3),
    base::round(model_comparison_unadj_zc$F[2], 3),
    base::round(model_comparison_unadj_all$F[2], 3),
    base::round(unadj_z_stat, 3),
    base::round(adj_z_z_stat, 3),
    base::round(adj_zc_z_stat, 3)
  ),
  
  PValue = base::c(
    base::round(model_comparison_unadj_z$`Pr(>F)`[2], 3),
    base::round(model_comparison_unadj_zc$`Pr(>F)`[2], 3),
    base::round(model_comparison_unadj_all$`Pr(>F)`[2], 3),
    base::round(unadj_p_value, 3),
    base::round(adj_z_p_value, 3),
    base::round(adj_zc_p_value, 3)
  ),
  
  Conclusion = base::c(
    base::ifelse(model_comparison_unadj_z$`Pr(>F)`[2] < 0.05, 
           "Adjusted model significantly improves fit", 
           "No significant improvement in model fit"),
    
    base::ifelse(model_comparison_unadj_zc$`Pr(>F)`[2] < 0.05,
           "Adjusted model significantly improves fit",
           "No significant improvement in model fit"),
    
    base::ifelse(model_comparison_unadj_all$`Pr(>F)`[2] < 0.05,
           "Full model significantly improves fit",
           "No significant improvement in model fit"),
    
    base::ifelse(unadj_p_value < 0.05,
           "Unadjusted estimate significantly differs from true effect",
           "Unadjusted estimate not significantly different from true effect"),
    
    base::ifelse(adj_z_p_value < 0.05,
           "Adjusted estimate significantly differs from true effect",
           "Adjusted estimate not significantly different from true effect"),
    
    base::ifelse(adj_zc_p_value < 0.05,
           "Adjusted estimate significantly differs from true effect",
           "Adjusted estimate not significantly different from true effect")
  )
)

# Display as a table
DT::datatable(significance_df,
          caption = "Statistical Tests for Model Performance in Experimental Design",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')

```

## Conclusions from Model Comparisons:

The statistical tests demonstrate the key principles of experimental design:

1. **Unbiased estimation without adjustment**: The unadjusted model provides an unbiased estimate of the causal effect, very close to the true value.

2. **Precision gains from prognostic adjustment**: While not necessary for unbiased estimation, adjusting for prognostic factors can improve precision (smaller standard errors).

3. **All approaches yield similar point estimates**: Because X is randomized, all modeling approaches yield similar estimates of the causal effect.

4. **Statistical efficiency trade-offs**: More complex models may provide better fit (higher R²) but don't necessarily improve the causal estimate.

## 11. Testing Randomization: Correlations between X and other variables

```{r}
#| label: randomization-tests
#| tbl-cap: "Testing independence of randomized treatment X"

# Test correlations between X and all other variables
randomization_tests <- base::data.frame(
  Variable_Pair = base::c("X and A", "X and B", "X and Z", "X and C"),
  Correlation = base::c(stats::cor(dag_data$X, dag_data$A), 
                  stats::cor(dag_data$X, dag_data$B),
                  stats::cor(dag_data$X, dag_data$Z), 
                  stats::cor(dag_data$X, dag_data$C)),
  P_Value = base::c(stats::cor.test(dag_data$X, dag_data$A)$p.value,
              stats::cor.test(dag_data$X, dag_data$B)$p.value,
              stats::cor.test(dag_data$X, dag_data$Z)$p.value,
              stats::cor.test(dag_data$X, dag_data$C)$p.value),
  Significant = base::c(stats::cor.test(dag_data$X, dag_data$A)$p.value < 0.05,
                  stats::cor.test(dag_data$X, dag_data$B)$p.value < 0.05,
                  stats::cor.test(dag_data$X, dag_data$Z)$p.value < 0.05,
                  stats::cor.test(dag_data$X, dag_data$C)$p.value < 0.05),
  Interpretation = base::c(
    "Independence confirmed - randomization successful",
    "Independence confirmed - randomization successful", 
    "Independence confirmed - randomization successful",
    "Independence confirmed - randomization successful"
  )
)

# Format the results
randomization_tests$Correlation <- base::round(randomization_tests$Correlation, 3)
randomization_tests$P_Value <- base::round(randomization_tests$P_Value, 3)

# Display as a table
DT::datatable(randomization_tests,
          caption = "Testing Independence of Randomized Exposure X",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

## Conclusions from Randomization Tests:

The randomization tests confirm the fundamental principle of experimental design:

1. **Exposure independence achieved**: X shows no significant correlation with any other variable in the system.

2. **Successful randomization**: The p-values are all non-significant, confirming that randomization broke the association between treatment and potential confounders.

3. **Causal identification guaranteed**: Because X is independent of all other causes of Y, the association between X and Y represents the pure causal effect.

## 12. Stratification Analysis

```{r}
#| label: stratification-analysis
#| fig-cap: "Stratified analysis showing consistency of treatment effect"
#| fig-subcap: 
#|   - "X-Y Relationship Stratified by Z"
#|   - "X-Y Relationship Stratified by C" 
#|   - "X-Y Relationship Stratified by B"
#|   - "X-Y Relationship Stratified by A"
#| layout-ncol: 2

# Create Z strata
dag_data <- dag_data |>
  dplyr::mutate(Z_strata = base::cut(Z, breaks = 3, labels = base::c("Low Z", "Medium Z", "High Z")))

# Stratified analysis by Z
p1 <- ggplot2::ggplot(dag_data, ggplot2::aes(x = X, y = Y, color = Z_strata)) +
   ggplot2::geom_point(alpha = 0.5) +
   ggplot2::geom_smooth(method = "lm", se = TRUE) +
   ggplot2::facet_wrap(~ Z_strata) +
   ggplot2::labs(title = "X-Y Relationship Stratified by Z",
       subtitle = "Exposure effect should be consistent across strata") +
   ggplot2::theme_minimal() +
   ggplot2::theme(legend.position = "bottom",
        plot.title = ggplot2::element_text(size = 28),
        plot.subtitle = ggplot2::element_text(size = 28))

base::print(p1)

# Create C strata
dag_data <- dag_data |>
  dplyr::mutate(C_strata = base::cut(C, breaks = 3, labels = base::c("Low C", "Medium C", "High C")))

# Stratified analysis by C
p2 <- ggplot2::ggplot(dag_data, ggplot2::aes(x = X, y = Y, color = C_strata)) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggplot2::facet_wrap(~ C_strata) +
  ggplot2::labs(title = "X-Y Relationship Stratified by C",
       subtitle = "Exposure effect should be consistent across strata") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
plot.title = ggplot2::element_text(size = 28),
        plot.subtitle = ggplot2::element_text(size = 28))
base::print(p2)

# Create B strata
dag_data <- dag_data |>
  dplyr::mutate(B_strata = base::cut(B, breaks = 3, labels = base::c("Low B", "Medium B", "High B")))

# Stratified analysis by B
p3 <- ggplot2::ggplot(dag_data, ggplot2::aes(x = X, y = Y, color = B_strata)) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggplot2::facet_wrap(~ B_strata) +
  ggplot2::labs(title = "X-Y Relationship Stratified by B",
       subtitle = "Exposure effect should be consistent across strata") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
plot.title = ggplot2::element_text(size = 28),
        plot.subtitle = ggplot2::element_text(size = 28))
base::print(p3)

# Create A strata
dag_data <- dag_data |>
  dplyr::mutate(A_strata = base::cut(A, breaks = 3, labels = base::c("Low A", "Medium A", "High A")))

# Stratified analysis by A
p4 <- ggplot2::ggplot(dag_data, ggplot2::aes(x = X, y = Y, color = A_strata)) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggplot2::facet_wrap(~ A_strata) +
  ggplot2::labs(title = "X-Y Relationship Stratified by A",
       subtitle = "Exposure effect should be consistent across strata") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
        plot.title = ggplot2::element_text(size = 28),
        plot.subtitle = ggplot2::element_text(size = 28))
base::print(p4)

```


## Conclusions from Stratification Analysis:

The stratified analysis demonstrates the power of randomization:

1. **Consistent treatment effect**: The slope of the X-Y relationship is similar across all strata of every variable, confirming no effect modification.

2. **Intercept variation expected**: Different strata show different intercepts because these variables independently affect Y.

3. **No confounding detected**: The consistency of slopes across strata confirms that randomization eliminated confounding.

4. **Robust causal estimate**: The treatment effect is stable regardless of the levels of other variables.



## 13. Structural Equation Modeling (SEM)

```{r}
#| label: sem-analysis
#| tbl-cap: "Structural Equation Model Results for Experimental Design"
#| eval: true



# Define the SEM model based on the experimental DAG
sem_model <- '
  # Structural equations (following the experimental DAG)
  Z ~ a1*A + b1*B
  Y ~ x1*X + z1*Z + c1*C + b2*B
  
  # X is exogenous (randomized) - no structural equation needed
  
  # Define indirect effects (none through X since it has no causes)
  A_to_Y_via_Z := a1*z1
  B_to_Y_via_Z := b1*z1
  B_to_Y_total := b2 + B_to_Y_via_Z
'

# Fit the model
sem_fit <- lavaan::sem(sem_model, data = dag_data)  # Explicitly use lavaan::sem


# Gather summary data
sem_summary <- base::summary(sem_fit, standardized = TRUE, fit.measures = TRUE)

# Extract and display path coefficients
sem_coefs <- lavaan::parameterEstimates(sem_fit) |>
  dplyr::filter(op %in% base::c("~", ":=")) |>
  dplyr::select(lhs, op, rhs, est, se, z, pvalue, ci.lower, ci.upper)



# Create a formatted results table
sem_results <- sem_coefs |>
  dplyr::mutate(
    Path = dplyr::case_when(
      op == "~" & lhs == "Z" ~ base::paste(lhs, "<-", rhs),
      op == "~" & lhs == "Y" ~ base::paste(lhs, "<-", rhs),
      op == ":=" & base::grepl("A_to_Y", rhs) ~ base::paste("A → Y (", base::gsub("A_to_Y_", "", rhs), ")"),
      op == ":=" & base::grepl("B_to_Y", rhs) ~ base::paste("B → Y (", base::gsub("B_to_Y_", "", rhs), ")"),
      TRUE ~ base::paste(lhs, op, rhs)
    ),
    Estimate = base::round(est, 3),
    SE = base::round(se, 3),
    `Z-value` = base::round(z, 3),
    `P-value` = base::round(pvalue, 3),
    `95% CI` = base::paste0("[", base::round(ci.lower, 3), ", ", base::round(ci.upper, 3), "]")
  ) |>
  dplyr::select(Path, Estimate, SE, `Z-value`, `P-value`, `95% CI`)  # Use dplyr::select


# Display the results table  
DT::datatable(sem_results,
          caption = "Structural Equation Model Path Coefficients for Experimental Design",
          options = base::list(pageLength = 15, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')

```

```{r}
#| label: sem-fit-measures
#| tbl-cap: "SEM Model Fit Measures for Experimental Design"

# Extract fit measures
fit_measures <- lavaan::fitMeasures(sem_fit)

# Create a table of key fit measures
fit_table <- base::data.frame(
  Measure = base::c("Chi-square", "df", "P-value", "CFI", "TLI", "RMSEA", "RMSEA CI Lower", "RMSEA CI Upper", "SRMR"),
  Value = base::c(
    base::round(fit_measures["chisq"], 3), 
    base::round(fit_measures["df"], 3),
    base::round(fit_measures["pvalue"], 3),
    base::round(fit_measures["cfi"], 3),
    base::round(fit_measures["tli"], 3),
    base::round(fit_measures["rmsea"], 3),
    base::round(fit_measures["rmsea.ci.lower"], 3),
    base::round(fit_measures["rmsea.ci.upper"], 3),
    base::round(fit_measures["srmr"], 3)
  ),
  Interpretation = base::c(
    "Model chi-square",
    "Degrees of freedom",
    "P-value for chi-square test",
    "Comparative Fit Index (>0.95 good)",
    "Tucker-Lewis Index (>0.95 good)",
    "Root Mean Square Error of Approximation (<0.06 good)",
    "RMSEA 95% CI lower bound",
    "RMSEA 95% CI upper bound", 
    "Standardized Root Mean Square Residual (<0.08 good)"
  )
)

DT::datatable(fit_table,
          caption = "Structural Equation Model Fit Indices for Experimental Design",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

## Conclusions from SEM Analysis:

The structural equation model confirms the experimental design principles:

1. **Excellent model fit**: All fit indices indicate the model represents the data well.

2. **Direct treatment effect**: The X → Y coefficient matches the expected causal effect closely.

3. **No indirect effects through X**: Since X is randomized, there are no indirect pathways from other variables through X.

4. **Other pathways quantified**: We can see how A and B affect Y through different mechanisms.

## 14. Examining Exposure Assignment Quality

```{r}
#| label: treatment-balance
#| fig-cap: "Examining balance of treatment assignment across other variables"

# Create treatment groups based on X (splitting at median for visualization)
dag_data <- dag_data |>
  dplyr::mutate(X_group = base::ifelse(X > stats::median(X), "High X", "Low X"))

# Test balance across variables
balance_tests <- base::data.frame(
  Variable = base::c("A", "B", "Z", "C"),
  High_X_Mean = base::c(
    base::mean(dag_data$A[dag_data$X_group == "High X"]),
    base::mean(dag_data$B[dag_data$X_group == "High X"]),
    base::mean(dag_data$Z[dag_data$X_group == "High X"]),
    base::mean(dag_data$C[dag_data$X_group == "High X"])
  ),
  Low_X_Mean = base::c(
    base::mean(dag_data$A[dag_data$X_group == "Low X"]),
    base::mean(dag_data$B[dag_data$X_group == "Low X"]),
    base::mean(dag_data$Z[dag_data$X_group == "Low X"]),
    base::mean(dag_data$C[dag_data$X_group == "Low X"])
  ),
  Difference = base::c(
    base::mean(dag_data$A[dag_data$X_group == "High X"]) - base::mean(dag_data$A[dag_data$X_group == "Low X"]),
    base::mean(dag_data$B[dag_data$X_group == "High X"]) - base::mean(dag_data$B[dag_data$X_group == "Low X"]),
    base::mean(dag_data$Z[dag_data$X_group == "High X"]) - base::mean(dag_data$Z[dag_data$X_group == "Low X"]),
    base::mean(dag_data$C[dag_data$X_group == "High X"]) - base::mean(dag_data$C[dag_data$X_group == "Low X"])
  ),
  T_Test_P_Value = base::c(
    stats::t.test(dag_data$A ~ dag_data$X_group)$p.value,
    stats::t.test(dag_data$B ~ dag_data$X_group)$p.value,
    stats::t.test(dag_data$Z ~ dag_data$X_group)$p.value,
    stats::t.test(dag_data$C ~ dag_data$X_group)$p.value
  )
)

# Format the results
balance_tests$High_X_Mean <- base::round(balance_tests$High_X_Mean, 3)
balance_tests$Low_X_Mean <- base::round(balance_tests$Low_X_Mean, 3)
balance_tests$Difference <- base::round(balance_tests$Difference, 3)
balance_tests$T_Test_P_Value <- base::round(balance_tests$T_Test_P_Value, 3)

# Add interpretation
balance_tests$Balanced <- base::ifelse(balance_tests$T_Test_P_Value > 0.05, "Yes", "No")

DT::datatable(balance_tests,
          caption = "Balance Tests: Distribution of Variables Across Exposure Groups",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

```{r}
#| label: balance-visualization
#| fig-cap: "Visual assessment of treatment balance"

# Create box plots to visualize balance
balance_plots <- base::list()

variables_to_plot <- base::c("A", "B", "Z", "C")

for(var in variables_to_plot) {
  p <- ggplot2::ggplot(dag_data, ggplot2::aes_string(x = "X_group", y = var, fill = "X_group")) +
    ggplot2::geom_boxplot(alpha = 0.7) +
    ggplot2::geom_jitter(width = 0.2, alpha = 0.3) +
    ggplot2::scale_fill_manual(values = base::c("lightblue", "lightcoral")) +
    ggplot2::theme_minimal() +
    ggplot2::labs(title = base::paste("Distribution of", var, "by Exposure Group"),
         x = "Exposure Group", y = var) +
    ggplot2::theme(legend.position = "none")
  
  balance_plots[[var]] <- p
}

# Arrange plots
ggpubr::ggarrange(balance_plots$A, balance_plots$B, balance_plots$Z, balance_plots$C,
          ncol = 2, nrow = 2)
```

## Conclusions from Exposure Balance Analysis:

The balance analysis confirms successful randomization:

1. **No significant differences**: All p-values > 0.05, indicating good balance between treatment groups.

2. **Small mean differences**: The differences between groups are small and non-significant.

3. **Visual confirmation**: Box plots show similar distributions across treatment groups.

4. **Randomization success**: These results confirm that randomization successfully balanced observed covariates.

## 15. Power Analysis for Experimental Design

```{r}
#| label: power-analysis
#| tbl-cap: "Power analysis for detecting treatment effects"

# Calculate power for different effect sizes and sample sizes
effect_sizes <- base::c(0.2, 0.3, 0.4, 0.5, 0.6)
sample_sizes <- base::c(100, 250, 500, 750, 1000)

# Function to calculate power for a given effect size and sample size
calculate_power <- function(effect_size, n, alpha = 0.05) {
  # Assume residual standard error from the model
  residual_se <- base::summary(model_unadjusted)$sigma
  
  # Standard error of treatment coefficient
  se_treatment <- residual_se / base::sqrt(base::sum((dag_data$X - base::mean(dag_data$X))^2))
  
  # Adjust for sample size
  se_treatment_adj <- se_treatment * base::sqrt(1000 / n)
  
  # Calculate power
  t_critical <- stats::qt(1 - alpha/2, df = n - 2)
  power <- 1 - stats::pt(t_critical, df = n - 2, ncp = effect_size / se_treatment_adj) +
           stats::pt(-t_critical, df = n - 2, ncp = effect_size / se_treatment_adj)
  
  return(power)
}

# Create power analysis table
power_analysis <- base::expand.grid(
  Effect_Size = effect_sizes,
  Sample_Size = sample_sizes
)

power_analysis$Power <- base::mapply(calculate_power, 
                               power_analysis$Effect_Size, 
                               power_analysis$Sample_Size)

# Format and display
power_analysis$Power <- base::round(power_analysis$Power, 3)

# Reshape for better display
power_wide <- power_analysis |>
  tidyr::pivot_wider(names_from = Sample_Size, values_from = Power, names_prefix = "N_")

DT::datatable(power_wide,
          caption = "Statistical Power for Different Effect Sizes and Sample Sizes",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

```{r}
#| label: power-visualization
#| fig-cap: "Power curves for different effect sizes"

# Create power curves
ggplot2::ggplot(power_analysis, ggplot2::aes(x = Sample_Size, y = Power, color = base::factor(Effect_Size))) +
  ggplot2::geom_line(size = 1.2) +
  ggplot2::geom_point(size = 2) +
  ggplot2::geom_hline(yintercept = 0.8, linetype = "dashed", color = "red") +
  ggplot2::scale_color_viridis_d(name = "Effect Size") +
  ggplot2::labs(title = "Statistical Power vs Sample Size for Different Effect Sizes",
       subtitle = "Red dashed line shows 80% power threshold",
       x = "Sample Size", y = "Statistical Power") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom")
```

## Conclusions from Power Analysis:

The power analysis reveals important considerations for experimental design:

1. **Adequate power achieved**: Our sample size of 1000 provides excellent power (>90%) for detecting the true effect size of 0.4.

2. **Sample size requirements**: Smaller effect sizes require larger samples to achieve adequate power.

3. **Design efficiency**: Experimental designs are highly efficient for detecting causal effects compared to observational studies.

## 16. Bayesian Causal Inference Analysis

```{r}
#| label: bayesian-causal-analysis
#| message: false
#| warning: false
#| results: 'hide'

# Standardize variables for better model fitting
dag_data_std <- dag_data |>
  dplyr::mutate(dplyr::across(dplyr::where(is.numeric), scale)) |>
  base::data.frame()

# Define and fit Bayesian models
# 1. Unadjusted model (correct for experimental design)
m_unadj <- rethinking::quap(
  alist(
    Y ~ dnorm(mu, sigma),
    mu <- a + bX * X,
    a ~ dnorm(0, 1),
    bX ~ dnorm(0, 1),
    sigma ~ dexp(1)
  ),
  data = dag_data_std
)

# 2. Adjusted for prognostic factors (for precision)
m_prog <- rethinking::quap(
  alist(
    Y ~ dnorm(mu, sigma),
    mu <- a + bX * X + bZ * Z + bC * C + bB * B,
    a ~ dnorm(0, 1),
    bX ~ dnorm(0, 1),
    bZ ~ dnorm(0, 1),
    bC ~ dnorm(0, 1),
    bB ~ dnorm(0, 1),
    sigma ~ dexp(1)
  ),
  data = dag_data_std
)

# 3. Full model with all variables
m_full <- rethinking::quap(
  alist(
    Y ~ dnorm(mu, sigma),
    mu <- a + bX * X + bZ * Z + bC * C + bB * B + bA * A,
    a ~ dnorm(0, 1),
    bX ~ dnorm(0, 1),
    bZ ~ dnorm(0, 1),
    bC ~ dnorm(0, 1),
    bB ~ dnorm(0, 1),
    bA ~ dnorm(0, 1),
    sigma ~ dexp(1)
  ),
  data = dag_data_std
)
```

```{r}
#| label: extract-bayesian-posteriors
#| tbl-cap: "Bayesian estimates of the treatment effect"

# Extract samples from the posterior distributions
post_unadj <- rethinking::extract.samples(m_unadj)
post_prog <- rethinking::extract.samples(m_prog)
post_full <- rethinking::extract.samples(m_full)

# Create a function to summarize posteriors
summarize_posterior <- function(posterior, name) {
  base::data.frame(
    Model = name,
    Mean = base::mean(posterior$bX),
    Median = stats::median(posterior$bX),
    SD = stats::sd(posterior$bX),
    CI_Lower = stats::quantile(posterior$bX, 0.025),
    CI_Upper = stats::quantile(posterior$bX, 0.975),
    Width = stats::quantile(posterior$bX, 0.975) - stats::quantile(posterior$bX, 0.025)
  )
}

# Summarize the models
bayesian_results <- base::rbind(
  summarize_posterior(post_unadj, "Unadjusted (Correct for RCT)"),
  summarize_posterior(post_prog, "Adjusted for Prognostic Factors"),
  summarize_posterior(post_full, "Full Model")
)

# Display the results
DT::datatable(bayesian_results,
          caption = "Bayesian estimates of the treatment effect under different models",
          options = base::list(pageLength = 5, dom = 't'),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive') |>
  DT::formatRound(columns = base::c("Mean", "Median", "SD", "CI_Lower", "CI_Upper", "Width"), digits = 3)
```

```{r}
#| label: plot-bayesian-posteriors
#| fig-width: 10
#| fig-height: 6
#| fig-cap: "Posterior distributions of treatment effect estimates"

# Create a data frame with the posterior samples
all_posteriors <- base::data.frame(
  `Unadjusted (Correct)` = post_unadj$bX,
  `Prognostic Adjustment` = post_prog$bX,
  `Full Model` = post_full$bX,
  check.names = FALSE
)

# Convert to long format for plotting
long_posteriors <- all_posteriors |>
  tidyr::pivot_longer(cols = tidyr::everything(),
               names_to = "Model",
               values_to = "Effect_Estimate")

# Set factor levels for consistent ordering
long_posteriors$Model <- base::factor(long_posteriors$Model,
                                levels = base::c("Unadjusted (Correct)", "Prognostic Adjustment", "Full Model"))

# Plot density curves for all models
ggplot2::ggplot(long_posteriors, ggplot2::aes(x = Effect_Estimate, fill = Model)) +
  ggplot2::geom_density(alpha = 0.6) +
  ggplot2::geom_vline(data = bayesian_results,
             ggplot2::aes(xintercept = Mean, color = Model),
             linetype = "dashed", size = 1) +
  ggplot2::scale_fill_brewer(palette = "Set1") +
  ggplot2::scale_color_brewer(palette = "Set1") +
  ggplot2::labs(
    title = "Posterior Distributions of the Exposure Effect",
    subtitle = "All models provide similar estimates due to randomization",
    x = "Exposure Effect (Standardized)",
    y = "Density"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom")
```

## Interpretation of Bayesian Analysis:

The Bayesian analysis demonstrates key experimental design principles:

1. **Consistent estimates**: All models yield very similar posterior distributions for the treatment effect.

2. **Precision gains**: Adjusting for prognostic factors narrows the credible intervals without changing the point estimate.

3. **Robustness**: The treatment effect estimate is robust across different modeling approaches.

## 17. Counterfactual Analysis: Exposure Effect Estimation

```{r}
#| label: counterfactual-analysis
#| fig-cap: "Counterfactual predictions under different treatment levels"

# Function to predict Y based on different treatment levels
predict_counterfactual <- function(x_values, data = dag_data) {
  # Use the unadjusted model (correct for experimental design)
  model <- stats::lm(Y ~ X, data = data)
  intercept <- stats::coef(model)[1]
  x_coef <- stats::coef(model)[2]
  
  # Predict Y for different values of X
  y_pred <- intercept + x_coef * x_values
  return(y_pred)
}

# Create a range of X values for intervention
x_range <- base::seq(base::min(dag_data$X), base::max(dag_data$X), length.out = 100)

# Predict Y for different treatment levels
y_pred <- predict_counterfactual(x_range)

# Create a data frame for plotting
counterfactual_df <- base::data.frame(X = x_range, Y = y_pred)

# Plot the counterfactual prediction
ggplot2::ggplot() +
  # Add actual data points
  ggplot2::geom_point(data = dag_data, 
                      ggplot2::aes(x = X, y = Y), alpha = 0.2, color = "gray") +
  # Add counterfactual prediction
  ggplot2::geom_line(data = counterfactual_df, ggplot2::aes(x = X, y = Y),
            color = "red", size = 1.5) +
  ggplot2::labs(
    title = "Counterfactual Prediction: Exposure Effect",
    subtitle = "Red line shows the causal effect of treatment on outcome",
    x = "X (Exposure Level)",
    y = "Y (Outcome)"
  ) +
  ggplot2::theme_minimal()
```

```{r}
#| label: treatment-effect-table
#| tbl-cap: "Estimated treatment effects under different interventions"

# Calculate treatment effects for specific interventions
intervention_effects <- base::data.frame(
  Intervention = base::c(
    "Increase treatment by 1 unit",
    "Increase treatment by 2 units",
    "Move from 25th to 75th percentile",
    "Move from minimum to maximum treatment"
  ),
  X_Change = base::c(
    1,
    2,
    stats::quantile(dag_data$X, 0.75) - stats::quantile(dag_data$X, 0.25),
    base::max(dag_data$X) - base::min(dag_data$X)
  ),
  Expected_Y_Change = base::c(
    1 * stats::coef(model_unadjusted)["X"],
    2 * stats::coef(model_unadjusted)["X"],
    (stats::quantile(dag_data$X, 0.75) - stats::quantile(dag_data$X, 0.25)) * stats::coef(model_unadjusted)["X"],
    (base::max(dag_data$X) - base::min(dag_data$X)) * stats::coef(model_unadjusted)["X"]
  )
)

# Format the results
intervention_effects$X_Change <- base::round(intervention_effects$X_Change, 3)
intervention_effects$Expected_Y_Change <- base::round(intervention_effects$Expected_Y_Change, 3)

DT::datatable(intervention_effects,
          caption = "Expected outcomes under different treatment interventions",
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

## Conclusions from Counterfactual Analysis:

The counterfactual analysis demonstrates the practical implications of the treatment effect:

1. **Linear treatment response**: The relationship between treatment level and outcome is linear.

2. **Predictable interventions**: We can precisely predict the outcome change for any treatment intervention.

3. **Policy implications**: The analysis provides clear guidance for optimal treatment levels.

## 18. Sensitivity Analysis: What if randomization failed?

```{r}
#| label: sensitivity-analysis
#| fig-cap: "Impact of potential confounding if randomization had failed"

# Function to simulate what would happen if randomization had failed
simulate_confounding <- function(confounding_strength) {
  # Create a scenario where X is influenced by a hidden confounder U
  base::set.seed(123)
  n <- 1000
  
  # Generate unmeasured confounder U
  U <- stats::rnorm(n, mean = 0, sd = 1)
  
  # X is now influenced by U (simulating failed randomization)
  X_confounded <- confounding_strength * U + base::sqrt(1 - confounding_strength^2) * stats::rnorm(n, sd = 1)
  
  # Y is influenced by both X and U
  Y_confounded <- 0.4 * X_confounded + 0.3 * U + stats::rnorm(n, sd = 0.6)
  
  # Estimate the apparent effect (biased due to confounding)
  apparent_effect <- stats::coef(stats::lm(Y_confounded ~ X_confounded))[2]
  
  return(apparent_effect)
}

# Test different levels of confounding
confounding_levels <- base::seq(0, 0.8, by = 0.1)
sensitivity_results <- base::data.frame(
  Confounding_Strength = confounding_levels,
  Apparent_Effect = base::sapply(confounding_levels, simulate_confounding),
  True_Effect = 0.4,
  Bias = base::sapply(confounding_levels, simulate_confounding) - 0.4
)

# Format results
sensitivity_results$Apparent_Effect <- base::round(sensitivity_results$Apparent_Effect, 3)
sensitivity_results$Bias <- base::round(sensitivity_results$Bias, 3)
sensitivity_results$Bias_Percent <- base::round(100 * sensitivity_results$Bias / 0.4, 1)

DT::datatable(sensitivity_results,
          caption = "Sensitivity Analysis: Impact of Failed Randomization",
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

```{r}
#| label: sensitivity-visualization
#| fig-cap: "Bias introduced by confounding when randomization fails"

# Plot the sensitivity analysis
ggplot2::ggplot(sensitivity_results, ggplot2::aes(x = Confounding_Strength, y = Apparent_Effect)) +
  ggplot2::geom_line(size = 1.2, color = "blue") +
  ggplot2::geom_point(size = 3, color = "blue") +
  ggplot2::geom_hline(yintercept = 0.4, linetype = "dashed", color = "red", size = 1) +
  ggplot2::labs(
    title = "Sensitivity Analysis: Bias from Failed Randomization",
    subtitle = "Red dashed line shows true causal effect (0.4)",
    x = "Confounding Strength",
    y = "Apparent Exposure Effect"
  ) +
  ggplot2::theme_minimal()
```

## Conclusions from Sensitivity Analysis:

The sensitivity analysis highlights the value of randomization:

1. **Perfect randomization (0.0 confounding)**: Produces unbiased estimates of the true effect.

2. **Increasing bias with confounding**: As confounding strength increases, bias grows substantially.

3. **Randomization superiority**: Even small amounts of confounding can lead to meaningful bias.

4. **Experimental design advantage**: Proper randomization eliminates this source of bias entirely.

## 19. Forest Plot Visualization of Exposure Effects

```{r}
#| label: forest-plot
#| fig-cap: "Forest plot of treatment effect estimates under different modeling approaches"

# Create forest plot data from the comparison table
forest_data <- comparison_df |>
  dplyr::filter(Model != "True Causal Effect") |>
  dplyr::mutate(
    Model = base::factor(Model, levels = rev(base::c(
      "Unadjusted (Correct for RCT)",
      "Adjusted for Z (Prognostic)",
      "Adjusted for C (Prognostic)", 
      "Adjusted for B (Prognostic)",
      "Adjusted for Z, C (Multiple Prognostic)",
      "Adjusted for All Variables"
    ))),
    CI_Lower = Coefficient - 1.96 * StandardError,
    CI_Upper = Coefficient + 1.96 * StandardError
  )

# Plot forest plot
ggplot2::ggplot(forest_data, 
                ggplot2::aes(x = Coefficient, y = Model,
                       xmin = CI_Lower, xmax = CI_Upper)) +
  ggplot2::geom_pointrange(size = 0.8, color = "darkgreen") +
  ggplot2::geom_vline(xintercept = true_effect, linetype = "dashed", color = "red", size = 1) +
  ggplot2::labs(
    title = "Exposure Effect Estimates Under Different Modeling Approaches",
    subtitle = "Dashed line represents the true causal effect (0.4)",
    x = "Estimated Exposure Effect",
    y = "Modeling Approach"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.y = ggplot2::element_text(size = 10))
```

## Conclusions from Forest Plot:

The forest plot illustrates the robustness of experimental design:

1. **Consistent estimates**: All modeling approaches yield similar point estimates.

2. **Precision trade-offs**: Some adjusted models have narrower confidence intervals (higher precision).

3. **Robust causal inference**: The treatment effect estimate is stable regardless of the modeling approach.

## 20. Mediation Analysis: Decomposing Exposure Effects

```{r}
#| label: mediation-analysis
#| tbl-cap: "Mediation analysis: Are there indirect effects through Z?"

# Since Z is affected by A and B, but not by X (due to randomization),
# there should be no mediation of the X → Y effect through Z

# Test for mediation using the traditional Baron & Kenny approach
# Step 1: X should predict Y (already established)
step1_model <- stats::lm(Y ~ X, data = dag_data)
step1_significant <- base::summary(step1_model)$coefficients["X", "Pr(>|t|)"] < 0.05

# Step 2: X should predict the mediator Z
step2_model <- stats::lm(Z ~ X, data = dag_data)  
step2_significant <- base::summary(step2_model)$coefficients["X", "Pr(>|t|)"] < 0.05

# Step 3: Z should predict Y when controlling for X
step3_model <- stats::lm(Y ~ X + Z, data = dag_data)
step3_significant <- base::summary(step3_model)$coefficients["Z", "Pr(>|t|)"] < 0.05

# Step 4: The effect of X on Y should be reduced when Z is included
direct_effect <- stats::coef(step1_model)["X"]
direct_effect_with_mediator <- stats::coef(step3_model)["X"]
mediation_effect <- direct_effect - direct_effect_with_mediator

# Create mediation results table
mediation_results <- base::data.frame(
  Step = base::c("1. X → Y (total effect)", 
           "2. X → Z (treatment → mediator)",
           "3. Z → Y|X (mediator → outcome)",
           "4. X → Y|Z (direct effect)"),
  Coefficient = base::c(
    stats::coef(step1_model)["X"],
    stats::coef(step2_model)["X"],
    stats::coef(step3_model)["Z"],
    stats::coef(step3_model)["X"]
  ),
  P_Value = base::c(
    base::summary(step1_model)$coefficients["X", "Pr(>|t|)"],
    base::summary(step2_model)$coefficients["X", "Pr(>|t|)"],
    base::summary(step3_model)$coefficients["Z", "Pr(>|t|)"],
    base::summary(step3_model)$coefficients["X", "Pr(>|t|)"]
  ),
  Significant = base::c(step1_significant, step2_significant, step3_significant, TRUE),
  Interpretation = base::c(
    "Total treatment effect (significant)",
    "No treatment effect on Z (randomization successful)",
    "Z affects outcome (prognostic factor)",
    "Direct treatment effect unchanged"
  )
)

# Format results
mediation_results$Coefficient <- base::round(mediation_results$Coefficient, 3)
mediation_results$P_Value <- base::round(mediation_results$P_Value, 3)

DT::datatable(mediation_results,
          caption = "Mediation Analysis: Testing for Indirect Effects",
          options = base::list(pageLength = 10, scrollX = TRUE),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')

# Summary of mediation
mediation_summary <- base::data.frame(
  Effect_Type = base::c("Total Effect", "Direct Effect", "Indirect Effect (Mediation)", "Proportion Mediated"),
  Value = base::c(direct_effect, direct_effect_with_mediator, mediation_effect, mediation_effect/direct_effect),
  Interpretation = base::c(
    "Overall treatment effect",
    "Direct treatment effect (controlling for Z)",
    "Effect mediated through Z", 
    "Proportion of effect that is mediated"
  )
)

mediation_summary$Value <- base::round(mediation_summary$Value, 3)

DT::datatable(mediation_summary,
          caption = "Mediation Analysis Summary",
          options = base::list(pageLength = 10, dom = 't'),
          rownames = FALSE,
          class = 'cell-border stripe compact responsive')
```

## Conclusions from Mediation Analysis:

The mediation analysis confirms the experimental design structure:

1. **No mediation detected**: Step 2 fails because X does not predict Z (due to randomization).

2. **Randomization eliminates mediation**: Since X is randomly assigned, it cannot affect mediators.

3. **Z is prognostic, not mediating**: Z affects the outcome but is not on the causal pathway from X to Y.

4. **Pure direct effect**: The entire treatment effect is direct, with no indirect pathways.

## 21. Practical Implications and Conclusions

### 21.1 Summary of Key Findings

Our comprehensive analysis of the experimental causal structure has revealed several fundamental insights about randomized controlled trials:

1. **Randomization eliminates confounding**: The independence of X from all other variables ensures unbiased causal estimates.

2. **No adjustment necessary**: The simple association between X and Y represents the true causal effect.

3. **Adjustment can improve precision**: While not necessary for unbiased estimation, controlling for prognostic factors may increase statistical efficiency.

4. **Robust across methods**: Frequentist, Bayesian, and SEM approaches all yield consistent results.

### 21.2 The Gold Standard of Causal Inference

This experimental structure represents why randomized controlled trials are considered the gold standard:

**Advantages of Randomization:**
- Eliminates selection bias
- Balances known and unknown confounders
- Allows simple, unbiased estimation of causal effects
- Provides strong evidence for causality

**Design Principles Demonstrated:**
- Exposure assignment must be truly independent
- Balance checks confirm successful randomization
- Simple analysis approaches are often best
- Complex adjustments may reduce efficiency without improving validity

### 21.3 Real-World Applications

This framework applies to numerous experimental contexts:

- **Clinical trials**: Testing drug efficacy with randomized treatment assignment
- **Educational interventions**: Evaluating program effectiveness with random student assignment
- **Policy experiments**: Testing policy changes with randomized implementation
- **Marketing studies**: A/B testing with random customer assignment

### 21.4 Comparison with Observational Studies

Unlike observational studies where confounding is a major threat:

- **No backdoor paths exist** between treatment and outcome
- **No adjustment sets needed** for causal identification
- **Higher internal validity** due to experimental control
- **Clearer causal interpretation** of results

### 21.5 Limitations and Considerations

Even experimental designs have limitations:

1. **External validity**: Results may not generalize beyond the experimental population
2. **Ethical constraints**: Not all treatments can be randomly assigned
3. **Practical limitations**: Randomization may not always be feasible
4. **Compliance issues**: Participants may not adhere to assigned treatments

### 21.6 Recommendations for Experimental Research

Based on this analysis, we recommend:

1. **Prioritize randomization quality**: Ensure truly random assignment mechanisms
2. **Check balance**: Verify that randomization achieved its intended effect
3. **Keep analysis simple**: Use straightforward analytical approaches when possible
4. **Consider precision**: Adjust for prognostic factors to improve statistical efficiency
5. **Test robustness**: Verify results are consistent across different analytical approaches

### 21.7 The Value of DAG Thinking in Experiments

Even in experimental settings, DAG thinking provides value:

- **Clarifies causal assumptions**: Makes explicit what randomization achieves
- **Guides analytical choices**: Helps distinguish necessary from optional adjustments
- **Informs design decisions**: Identifies which variables to measure and potentially control for
- **Communicates causal logic**: Provides clear visualization of the causal structure



This analysis demonstrates that experimental causal structures, while simpler than observational studies in terms of confounding, benefit greatly from careful causal thinking. The DAG framework helps researchers understand why randomization works, what it achieves, and how to analyze experimental data optimally. The key insight is that randomization's power lies in creating a causal structure where the treatment variable has no parents, eliminating all backdoor paths and allowing direct estimation of causal effects.

Think of randomization as being like a perfectly clean laboratory - it isolates the causal relationship of interest by controlling the experimental environment so thoroughly that confounding cannot occur. Just as a chemist can determine the effect of temperature on a reaction by controlling all other variables, a researcher can determine the causal effect of a treatment by randomly assigning it, thereby controlling for all potential confounders simultaneously.








## 22. Simpson's Paradox Detection Analysis

Simpson's Paradox occurs when the direction of an association between two variables reverses when conditioning on a third variable. In the experimental causal structure DAG, we can examine whether this phenomenon occurs by stratifying the data based on different levels of the prognostic factors Z, C, and B.

Think of Simpson's Paradox like a magic trick in statistics - what appears to be true at the surface level completely reverses when you look deeper. In the experimental DAG, we might find that overall, X appears to have one effect on Y, but within each level of the prognostic factors, the relationship tells a different story. However, because X is randomized, we would expect the relationship to remain consistent across strata.

### 22.1 Simpson's Paradox Detection Analysis

First, let's examine the overall relationship between X and Y, and then compare it to the relationship within different strata of Z:

```{r}
#| label: detect-simpsons-paradox-exp
#| message: false
#| warning: false

# Calculate overall correlation between X and Y
overall_cor <- stats::cor(dag_data$X, dag_data$Y)
overall_slope <- stats::coef(stats::lm(Y ~ X, data = dag_data))[2]

# Create Z quartiles for stratified analysis
dag_data$Z_quartile <- base::cut(dag_data$Z, 
                          breaks = stats::quantile(dag_data$Z, probs = base::c(0, 0.25, 0.5, 0.75, 1)), 
                          labels = base::c("Q1 (Low)", "Q2", "Q3", "Q4 (High)"),
                          include.lowest = TRUE)

# Calculate correlations and slopes within each Z quartile
stratified_results <- dag_data |>
  dplyr::group_by(Z_quartile) |>
  dplyr::summarise(
    n = dplyr::n(),
    cor_XY = stats::cor(X, Y),
    slope_XY = stats::coef(stats::lm(Y ~ X))[2],
    mean_Z = base::mean(Z),
    mean_X = base::mean(X),
    mean_Y = base::mean(Y),
    .groups = 'drop'
  )

# Add overall results for comparison
overall_results <- base::data.frame(
  Z_quartile = "Overall",
  n = base::nrow(dag_data),
  cor_XY = overall_cor,
  slope_XY = overall_slope,
  mean_Z = base::mean(dag_data$Z),
  mean_X = base::mean(dag_data$X),
  mean_Y = base::mean(dag_data$Y)
)

# Combine results
simpson_analysis <- dplyr::bind_rows(overall_results, stratified_results)

# Round for display
simpson_analysis <- simpson_analysis |>
  dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ base::round(., 3)))

# Display results
DT::datatable(simpson_analysis,
              caption = "Simpson's Paradox Detection: Overall vs Stratified Analysis by Z",
              options = base::list(pageLength = 10, scrollX = TRUE),
              colnames = base::c("Z Group", "N", "Correlation X-Y", "Slope X→Y", 
                          "Mean Z", "Mean X", "Mean Y")) |>
  DT::formatRound(columns = base::c("cor_XY", "slope_XY", "mean_Z", "mean_X", "mean_Y"), digits = 3)
```

### 22.2 Testing for Simpson's Paradox by Status

Let's formally test whether Simpson's Paradox is present by examining if the direction of association changes:

```{r}
#| label: test-simpsons-paradox-status-exp
#| message: false
#| warning: false

# Function to determine Simpson's Paradox status
detect_simpson_status <- function(overall_slope, stratified_slopes) {
  # Check if all stratified slopes have the same sign
  stratified_signs <- base::sign(stratified_slopes)
  overall_sign <- base::sign(overall_slope)
  
  # Simpson's Paradox occurs when overall sign differs from all stratified signs
  if (base::all(stratified_signs == stratified_signs[1]) && 
      overall_sign != stratified_signs[1]) {
    return("Strong Simpson's Paradox")
  } else if (base::any(stratified_signs != overall_sign)) {
    return("Partial Simpson's Paradox")
  } else {
    return("No Simpson's Paradox")
  }
}

# Get stratified slopes (excluding overall)
stratified_slopes <- stratified_results$slope_XY

# Determine Simpson's Paradox status
simpson_status <- detect_simpson_status(overall_slope, stratified_slopes)

# Create summary table
simpson_summary <- base::data.frame(
  Measure = base::c("Overall Slope", "Mean Stratified Slope", "Range of Stratified Slopes",
              "Overall Correlation", "Mean Stratified Correlation", "Simpson's Paradox Status"),
  Value = base::c(
    base::round(overall_slope, 3),
    base::round(base::mean(stratified_slopes), 3),
    base::paste(base::round(base::min(stratified_slopes), 3), "to", base::round(base::max(stratified_slopes), 3)),
    base::round(overall_cor, 3),
    base::round(base::mean(stratified_results$cor_XY), 3),
    simpson_status
  )
)

# Display summary
DT::datatable(simpson_summary,
              caption = "Simpson's Paradox Status Summary for Z Stratification",
              options = base::list(pageLength = 10, dom = 't'),
              colnames = base::c("Measure", "Value"))
```

### 22.3 Testing for Simpson's Paradox by Groups

Let's examine the phenomenon by creating binary high/low groups for multiple prognostic factors:

```{r}
#| label: test-simpsons-by-groups-exp
#| message: false
#| warning: false

# Create binary groups for Z, C, and B (high/low based on median split)
dag_data$Z_binary <- base::ifelse(dag_data$Z > stats::median(dag_data$Z), "High Z", "Low Z")
dag_data$C_binary <- base::ifelse(dag_data$C > stats::median(dag_data$C), "High C", "Low C")
dag_data$B_binary <- base::ifelse(dag_data$B > stats::median(dag_data$B), "High B", "Low B")

# Analyze binary groups for Z
binary_Z <- dag_data |>
  dplyr::group_by(Z_binary) |>
  dplyr::summarise(
    n = dplyr::n(),
    cor_XY = stats::cor(X, Y),
    slope_XY = stats::coef(stats::lm(Y ~ X))[2],
    mean_Z = base::mean(Z),
    .groups = 'drop'
  ) |>
  dplyr::mutate(Variable = "Z")

# Analyze binary groups for C
binary_C <- dag_data |>
  dplyr::group_by(C_binary) |>
  dplyr::summarise(
    n = dplyr::n(),
    cor_XY = stats::cor(X, Y),
    slope_XY = stats::coef(stats::lm(Y ~ X))[2],
    mean_C = base::mean(C),
    .groups = 'drop'
  ) |>
  dplyr::mutate(Variable = "C") |>
  dplyr::rename(Group = C_binary, mean_var = mean_C)

# Analyze binary groups for B
binary_B <- dag_data |>
  dplyr::group_by(B_binary) |>
  dplyr::summarise(
    n = dplyr::n(),
    cor_XY = stats::cor(X, Y),
    slope_XY = stats::coef(stats::lm(Y ~ X))[2],
    mean_B = base::mean(B),
    .groups = 'drop'
  ) |>
  dplyr::mutate(Variable = "B") |>
  dplyr::rename(Group = B_binary, mean_var = mean_B)

# Standardize column names for Z
binary_Z <- binary_Z |>
  dplyr::rename(Group = Z_binary, mean_var = mean_Z)

# Combine all binary analyses
all_binary <- dplyr::bind_rows(binary_Z, binary_C, binary_B)

# Round for display
all_binary <- all_binary |>
  dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ base::round(., 3)))

# Display binary group analysis
DT::datatable(all_binary,
              caption = "Binary Group Analysis for Simpson's Paradox Detection",
              options = base::list(pageLength = 10, scrollX = TRUE),
              colnames = base::c("Group", "N", "Correlation", "Slope", "Mean Variable", "Variable")) |>
  DT::formatRound(columns = base::c("cor_XY", "slope_XY", "mean_var"), digits = 3)
```

### 22.4 Visual Detection of Simpson's Paradox

Let's create visualizations to clearly demonstrate whether Simpson's Paradox is present in the experimental data:

```{r}
#| label: visualize-simpsons-paradox-exp
#| fig-cap: "Visual Detection of Simpson's Paradox in Experimental Data"
#| fig-subcap: 
#|   - "Overall relationship vs stratified relationships (Z quartiles)"
#|   - "Binary group analysis for Z with separate regression lines"
#|   - "Binary group analysis for C with separate regression lines"
#|   - "Slope comparison across different prognostic factor stratifications"
#| layout-ncol: 2

# Plot 1: Overall vs Stratified (Z Quartiles)
p1 <- ggplot2::ggplot(dag_data, 
                      ggplot2::aes(x = X, y = Y)) +
  # Overall regression line
  ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "red", linewidth = 1.5, 
              linetype = "dashed", se = FALSE) +
  # Stratified regression lines
  ggplot2::geom_smooth(ggplot2::aes(color = Z_quartile), method = "lm", formula = y ~ x, 
              linewidth = 1, se = FALSE) +
  # Points colored by quartile
  ggplot2::geom_point(ggplot2::aes(color = Z_quartile), alpha = 0.6) +
  ggplot2::scale_color_viridis_d(name = "Z Quartile") +
  ggplot2::labs(
    title = "Simpson's Paradox Analysis: Overall vs Z Stratified Relationships",
    subtitle = base::paste("Overall slope (red dashed):", base::round(overall_slope, 3),
                    "| Simpson's Status:", simpson_status),
    x = "X (Exposure)",
    y = "Y (Outcome)"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom")

# Plot 2: Binary Group Analysis for Z
p2 <- ggplot2::ggplot(dag_data, 
                      ggplot2::aes(x = X, y = Y)) +
  # Overall regression line
  ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "red", linewidth = 1.5, 
              linetype = "dashed", se = FALSE) +
  # Stratified regression lines for binary groups
  ggplot2::geom_smooth(ggplot2::aes(color = Z_binary), method = "lm", formula = y ~ x, 
              linewidth = 1.2, se = TRUE, alpha = 0.3) +
  # Points colored by binary group
  ggplot2::geom_point(ggplot2::aes(color = Z_binary), alpha = 0.6) +
  ggplot2::scale_color_manual(values = base::c("High Z" = "darkblue", "Low Z" = "darkgreen"),
                     name = "Z Group") +
  ggplot2::labs(
    title = "Binary Group Analysis for Z",
    subtitle = "Red dashed line: Overall relationship | Colored lines: Group-specific relationships",
    x = "X (Exposure)",
    y = "Y (Outcome)"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom")

# Plot 3: Binary Group Analysis for C
p3 <- ggplot2::ggplot(dag_data, 
                      ggplot2::aes(x = X, y = Y)) +
  # Overall regression line
  ggplot2::geom_smooth(method = "lm", formula = y ~ x, color = "red", linewidth = 1.5, 
              linetype = "dashed", se = FALSE) +
  # Stratified regression lines for binary groups
  ggplot2::geom_smooth(ggplot2::aes(color = C_binary), method = "lm", formula = y ~ x, 
              linewidth = 1.2, se = TRUE, alpha = 0.3) +
  # Points colored by binary group
  ggplot2::geom_point(ggplot2::aes(color = C_binary), alpha = 0.6) +
  ggplot2::scale_color_manual(values = base::c("High C" = "purple", "Low C" = "orange"),
                     name = "C Group") +
  ggplot2::labs(
    title = "Binary Group Analysis for C",
    subtitle = "Red dashed line: Overall relationship | Colored lines: Group-specific relationships",
    x = "X (Exposure)",
    y = "Y (Outcome)"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom")

# Plot 4: Slope Comparison
slope_comparison <- base::data.frame(
  Group = base::c("Overall", 
           base::paste("Z", stratified_results$Z_quartile), 
           base::paste("Z", base::unique(dag_data$Z_binary)),
           base::paste("C", base::unique(dag_data$C_binary)),
           base::paste("B", base::unique(dag_data$B_binary))),
  Slope = base::c(overall_slope, 
           stratified_results$slope_XY, 
           binary_Z$slope_XY,
           binary_C$slope_XY,
           binary_B$slope_XY),
  Type = base::c("Overall", 
          base::rep("Z Quartile", 4), 
          base::rep("Z Binary", 2),
          base::rep("C Binary", 2),
          base::rep("B Binary", 2))
)

p4 <- ggplot2::ggplot(slope_comparison,
                      ggplot2::aes(x = reorder(Group, Slope), y = Slope, fill = Type)) +
  ggplot2::geom_col(alpha = 0.8) +
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  ggplot2::geom_hline(yintercept = 0.4, linetype = "dotted", color = "red", alpha = 0.7) +
  ggplot2::scale_fill_manual(values = base::c("Overall" = "red", "Z Quartile" = "steelblue", 
                              "Z Binary" = "darkgreen", "C Binary" = "purple", 
                              "B Binary" = "orange")) +
  ggplot2::labs(
    title = "Slope Comparison Across Different Stratifications",
    subtitle = "Red dotted line shows true causal effect (0.4)",
    x = "Group",
    y = "Slope of X → Y"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))

# Display plots
p1
p2
p3
p4
```

### 22.5 Formal Statistical Test for Simpson's Paradox

Let's conduct a simplified statistical test to quantify the evidence for Simpson's Paradox:

```{r}
#| label: formal-test-simpsons-paradox-exp
#| message: false
#| warning: false

# Simple test comparing overall slope to stratified slopes
# Calculate differences from overall slope
slope_differences <- base::data.frame(
  Stratification = base::c(
    base::paste("Z", stratified_results$Z_quartile),
    base::paste("Z", base::unique(dag_data$Z_binary)),
    base::paste("C", base::unique(dag_data$C_binary)),
    base::paste("B", base::unique(dag_data$B_binary))
  ),
  Slope = base::c(
    stratified_results$slope_XY,
    binary_Z$slope_XY,
    binary_C$slope_XY,
    binary_B$slope_XY
  ),
  Difference_from_Overall = base::c(
    stratified_results$slope_XY - overall_slope,
    binary_Z$slope_XY - overall_slope,
    binary_C$slope_XY - overall_slope,
    binary_B$slope_XY - overall_slope
  ),
  Variable = base::c(
    base::rep("Z (Quartiles)", 4),
    base::rep("Z (Binary)", 2),
    base::rep("C (Binary)", 2),
    base::rep("B (Binary)", 2)
  )
)

# Round for display
slope_differences <- slope_differences |>
  dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ base::round(., 3)))

# Add interpretation
slope_differences$Interpretation <- base::ifelse(
  base::abs(slope_differences$Difference_from_Overall) > 0.05,
  "Notable difference",
  "Minimal difference"
)

# Display test results
DT::datatable(slope_differences,
              caption = "Statistical Assessment of Slope Differences Across Strata",
              options = base::list(pageLength = 10, scrollX = TRUE)) |>
  DT::formatRound(columns = base::c("Slope", "Difference_from_Overall"), digits = 3)
```

### 22.6 Magnitude of Simpson's Paradox Effect

Let's quantify the magnitude of any Simpson's Paradox effect:

```{r}
#| label: magnitude-simpsons-effect-exp
#| message: false
#| warning: false

# Calculate magnitude measures for different stratifications
magnitude_analysis <- base::data.frame(
  Stratification = base::c("Z Quartiles", "Z Binary", "C Binary", "B Binary"),
  Overall_Slope = base::rep(base::round(overall_slope, 3), 4),
  Mean_Stratified_Slope = base::c(
    base::round(base::mean(stratified_results$slope_XY), 3),
    base::round(base::mean(binary_Z$slope_XY), 3),
    base::round(base::mean(binary_C$slope_XY), 3),
    base::round(base::mean(binary_B$slope_XY), 3)
  ),
  Max_Difference = base::c(
    base::round(base::max(base::abs(stratified_results$slope_XY - overall_slope)), 3),
    base::round(base::max(base::abs(binary_Z$slope_XY - overall_slope)), 3),
    base::round(base::max(base::abs(binary_C$slope_XY - overall_slope)), 3),
    base::round(base::max(base::abs(binary_B$slope_XY - overall_slope)), 3)
  ),
  Direction_Reversal = base::c(
    base::ifelse(base::any(base::sign(stratified_results$slope_XY) != base::sign(overall_slope)), "Yes", "No"),
    base::ifelse(base::any(base::sign(binary_Z$slope_XY) != base::sign(overall_slope)), "Yes", "No"),
    base::ifelse(base::any(base::sign(binary_C$slope_XY) != base::sign(overall_slope)), "Yes", "No"),
    base::ifelse(base::any(base::sign(binary_B$slope_XY) != base::sign(overall_slope)), "Yes", "No")
  )
)

# Display magnitude analysis
DT::datatable(magnitude_analysis,
              caption = "Magnitude of Simpson's Paradox Effect Across Stratifications",
              options = base::list(pageLength = 10, scrollX = TRUE),
              colnames = base::c("Stratification", "Overall Slope", "Mean Stratified Slope", 
                          "Max Difference", "Direction Reversal"))
```

### 22.7 Weighted vs Unweighted Analysis

Let's compare weighted and unweighted analyses:

```{r}
#| label: weighted-unweighted-analysis-exp
#| message: false
#| warning: false

# Calculate weighted averages for each stratification
weighted_analysis <- data.frame(
  Stratification = c("Z Quartiles", "Z Binary", "C Binary", "B Binary"),
  Unweighted_Mean = c(
    round(mean(stratified_results$slope_XY), 3),
    round(mean(binary_Z$slope_XY), 3),
    round(mean(binary_C$slope_XY), 3),
    round(mean(binary_B$slope_XY), 3)
  ),
  
  Weighted_Mean = c(
  round(stats::weighted.mean(stratified_results$slope_XY, stratified_results$n), 3),
  round(stats::weighted.mean(binary_Z$slope_XY, binary_Z$n), 3),
  round(stats::weighted.mean(binary_C$slope_XY, binary_C$n), 3),
  round(stats::weighted.mean(binary_B$slope_XY, binary_B$n), 3)
),

  Overall_Slope = rep(base::round(overall_slope, 3), 4)
)

# Add difference measures
weighted_analysis$Unweighted_Diff <- abs(weighted_analysis$Unweighted_Mean - weighted_analysis$Overall_Slope)
weighted_analysis$Weighted_Diff <- abs(weighted_analysis$Weighted_Mean - weighted_analysis$Overall_Slope)

# Round differences
weighted_analysis <- weighted_analysis |>
  dplyr::mutate(dplyr::across(c(Unweighted_Diff, Weighted_Diff), ~ base::round(., 3)))

# Display weighted analysis
DT::datatable(weighted_analysis,
              caption = "Weighted vs Unweighted Analysis Comparison",
              options = list(pageLength = 10, scrollX = TRUE),
              colnames = c("Stratification", "Unweighted Mean", "Weighted Mean", 
                          "Overall Slope", "Unweighted Diff", "Weighted Diff"))

```

### 22.8 Conclusions from Simpson's Paradox Analysis

Based on the comprehensive analysis, here are the key findings about Simpson's Paradox in this experimental dataset:

```{r}
#| label: simpsons-conclusions-exp
#| message: false
#| warning: false

# Calculate summary statistics
avg_max_difference <- base::mean(magnitude_analysis$Max_Difference)
any_direction_reversal <- base::any(magnitude_analysis$Direction_Reversal == "Yes")
dominant_status <- simpson_status

# Create conclusions summary
conclusions_data <- base::data.frame(
  Finding = base::c(
    "Simpson's Paradox Present?",
    "Direction Reversals Detected?",
    "Average Maximum Difference",
    "Consistency Across Strata",
    "Experimental Design Effect",
    "Practical Implication"
  ),
  Result = base::c(
    dominant_status,
    base::ifelse(any_direction_reversal, "Yes", "No"),
    base::paste(base::round(avg_max_difference, 3), "units"),
    "High consistency across all prognostic factor strata", 
    "Randomization prevents systematic Simpson's Paradox",
    "Simple analysis provides unbiased causal estimates"
  )
)

# Display conclusions
DT::datatable(conclusions_data,
              caption = "Summary of Simpson's Paradox Analysis Conclusions",
              options = base::list(pageLength = 10, dom = 't', scrollX = TRUE),
              colnames = base::c("Key Finding", "Result/Interpretation"))

# Create final summary
final_summary <- base::data.frame(
  Category = base::c(
    "Simpson's Paradox Detection",
    "Magnitude Analysis", 
    "Experimental Design Validation",
    "Causal Inference Implications"
  ),
  Key_Result = base::c(
    base::paste("Status:", dominant_status),
    base::paste("Average max difference:", base::round(avg_max_difference, 3), "units"),
    "Randomization maintains consistent treatment effects across strata",
    "Confirms experimental design eliminates confounding bias"
  ),
  Interpretation = base::c(
    "Minimal paradox occurrence due to randomized treatment assignment",
    "Small variations represent sampling variation, not systematic bias",
    "Treatment effect remains stable regardless of prognostic factor levels", 
    "Supports using simple unadjusted analysis for causal inference"
  )
)

DT::datatable(final_summary,
              caption = "Key Conclusions from Simpson's Paradox Analysis in Experimental Design",
              options = base::list(pageLength = 10, dom = 't', scrollX = TRUE),
              colnames = base::c("Category", "Key Result", "Interpretation"))
```

The Simpson's Paradox analysis reveals important insights about experimental design and causal inference. In this experimental dataset, we observe **`r dominant_status`**, which demonstrates how randomization of X prevents the systematic occurrence of Simpson's Paradox that might be seen in observational data.

The key insight is that Simpson's Paradox rarely occurs in well-designed experiments because randomization breaks the association between treatment assignment and potential confounders. In the experimental structure DAG, the prognostic factors Z, C, and B affect the outcome Y but are independent of the randomized exposure X, creating a causal structure where the marginal and conditional relationships remain consistent.

The minimal variation we observe across strata (average maximum difference of **`r base::round(avg_max_difference, 3)`** units) represents normal sampling variation rather than systematic confounding. This analysis reinforces the earlier findings about the power of randomization in eliminating confounding and ensuring that simple analyses provide unbiased causal estimates.

The absence of meaningful Simpson's Paradox in the experimental data underscores a fundamental principle: when treatment assignment is truly randomized, the causal effect can be estimated without complex adjustments or concerns about paradoxical reversals across subgroups. This is why randomized controlled trials remain the gold standard for causal inference - they create a causal structure where Simpson's Paradox cannot systematically mislead us about true causal relationships.








## Session Information for Reproducibility

```{r}
#| label: session-info

# Session information for reproducibility
# sessionInfo()
```

