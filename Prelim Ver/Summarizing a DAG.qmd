---
title: "Summarizing Causal DAG Analysis for HIV and Stroke"
subtitle: ""
description: ""
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 14pt
    mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: false
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: false
    error: false
    warning: false
    message: false
    cache: false

---


```{r}
#| label: setup
#| include: false
# R version 4.4.3 (2025-02-28)
# Platform: x86_64-apple-darwin20
# Running under: macOS Sequoia 15.6.1
# Rstudio 2025.9.2.418 (Cucumberleaf Sunflower)
# 

# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# @ load libraries

# library(BayesFactor) # Computation of Bayes Factors for Common Designs
# library(boot) # Bootstrap Functions
# library(broom) # Convert Statistical Objects into Tidy Tibbles
# library(colorspace) # A Toolbox for Manipulating and Assessing Colors and Palettes
# library(camcorder) # Record Your Plot History
# library(car) # Companion to Applied Regression
# library(causaldata) # Example Data Sets for Causal Inference Textbooks
# library(corrplot) # Visualization of a Correlation Matrix
# library(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'
# library(dagitty) # Graphical Analysis of Structural Causal Models  
# library(DiagrammeR) # Graph/Network Visualization 
# library(dlookr) # Tools for Data Diagnosis, Exploration, Transformation 
library(dplyr) # A Grammar of Data Manipulation
# library(DT) # A Wrapper of the JavaScript Library 'DataTables'
# library(dutchmasters) # Color Palettes based on Famous Paintings 
# library(flexdashboard) # R Markdown Format for Flexible Dashboards
# library(flextable) # Functions for Tabular Reporting  
# library(forcats) # Tools for Working with Categorical Variables (Factors)
# library(gganimate) # A Grammar of Animated Graphics
# library(ggcorrplot) # Visualization of a Correlation Matrix using 'ggplot2'
# library(ggdag) # Analyze and Create Elegant Directed Acyclic Graphs      
# library(ggforce) # Accelerating 'ggplot2' 
# library(gghighlight) # Highlight Lines and Points in 'ggplot2' 
# library(ggplot2) # Create Elegant Data Visualizations Using the Grammar of Graphics
# library(ggokabeito) # 'Okabe-Ito' Scales for 'ggplot2' and 'ggraph'
# library(ggpubr) # 'ggplot2' Based Publication Ready Plots
# library(ggrepel) # Automatically Position Non-Overlapping Text Labels with 'ggplot2'
# library(ggtext) # Improved Text Rendering Support for 'ggplot2' 
# library(ggthemes) # Extra Themes, Scales and Geoms for 'ggplot2'
# library(glue) # Interpreted String Literals    
# library(grid) # The Grid Graphics Package
# library(gt) # Easily Create Presentation-Ready Display Tables
# library(gtExtras) # Extending 'gt' for Beautiful HTML Tables
# library(halfmoon) # Techniques to Build Better Balance
# library(haven) # Import and Export 'SPSS', 'Stata' and 'SAS' Files
# library(here) # A Simpler Way to Find Your Files
# library(htmltools) # Tools for HTML
# library(htmlwidgets) # HTML Widgets for R
# library(janitor) # Simple Tools for Examining and Cleaning Dirty Data 
# library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax
# library(knitr) # A General-Purpose Package for Dynamic Report Generation in R   
# library(lavaan) # Latent Variable Analysis     
# library(lubridate) # Make Dealing with Dates a Little Easier
# library(monochromeR) # Easily Create, View and Use Monochrome Color Palettes 
# library(paletteer) # Comprehensive Collection of Color Palettes 
# library(patchwork) # The Composer of Plots
# library(plotly) # Create Interactive Web Graphics via 'plotly.js'
# library(ppcor) # Partial and Semi-Partial (Part) Correlation
# library(propensity) # A Toolkit for Calculating and Working with Propensity Scores
# library(prettycode) # Pretty Print R Code in the Terminal
# library(PSW) # Propensity Score Weighting Methods for Dichotomous Treatments
# library(purrr) # Functional Programming Tools
# library(pwr) # Basic Functions for Power Analysis
# library(qgraph) # Graph Plotting Methods, Psychometric Data Visualization and Graphical Model Estimation
# library(qicharts2) # Quality Improvement Charts
# library(RColorBrewer) # ColorBrewer Palettes 
# library(readr) # Read Rectangular Text Data
# library(readxl) # Read Excel Files
# library(rethinking) # Statistical Rethinking book package
# library(rlang) # Functions for Base Types and Core R and 'Tidyverse' Features
# library(rsample) # General Resampling Infrastructure
# library(scales) # Scale Functions for Visualization
# library(shiny) # Web Application Framework for R
# library(shinyobjects) # Access Reactive Data Interactively   
# library(skimr) # Compact and Flexible Summaries of Data
# library(stringr) # Simple, Consistent Wrappers for Common String Operations
# library(tibble) # Simple Data Frames
# library(tidycensus) # Load US Census Boundary and Attribute Data as 'tidyverse' and 'sf'-Ready Data Frames
# library(tidylog) # Logging for 'dplyr' and 'tidyr' Functions
# library(tidyr) # Tidy Messy Data
# library(tidytext) # Text Mining using 'dplyr', 'ggplot2', and Other Tidy Tools 
# library(tsibble) # Tidy Temporal Data Frames and Tools        
# library(viridis) # Colorblind-Friendly Color Maps for R 
# library(visdat) # Preliminary Visualization of Data
# library(vroom) # Read and Write Rectangular Text Data Quickly    
# library(wesanderson) # A Wes Anderson Palette Generator 
# library(writexl) # Export Data Frames to Excel 'xlsx' Format 
# library(WRS2) # A Collection of Robust Statistical Methods



# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Options
options(scipen = 999)
options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "firebrick") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
options(tigris_use_cache = TRUE)


# Set global theme for consistent plots
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 20) + 
                   ggplot2::theme(plot.title = ggplot2::element_text(face = "bold",
                                                                      size = 26),
                                  plot.subtitle = ggplot2::element_text(face = "bold",
                                                                         size = 24),
                                  axis.title.x = ggplot2::element_text(face = "bold",
                                                                        size = 22),
                                  axis.title.y = ggplot2::element_text(face = "bold",
                                                                        size = 22),
                                  axis.text.x = ggplot2::element_text(face = "bold",
                                                                       size = 22,
                                                                       angle = 45,
                                                                       hjust = 1),
                                  legend.position = "bottom",
                                  strip.text = ggplot2::element_text(face = "bold"),
                                  panel.spacing.x = grid::unit(1.5,
                                                                "cm"),
                                  panel.spacing.y = grid::unit(1.5,
                                                                "cm"),
                                  plot.margin = ggplot2::margin(20,
                                                                 20,
                                                                 20,
                                                                 20,
                                                                 "pt")))


# Set seed for reproducibility
set.seed(123)

```


<br>


## FAR, AND AWAY THE BEST DAG RENDERING IS USING DiagrammeR.

There is no analysis with DiagrammeR, but the DAG is awesome, and EASY. It is displayed in the Viewer where images can be saved.  Analysis follows below.

```{r DiagrammeR-DAG}
#| message: false
#| warning: false
#| echo: false

library(DiagrammeR)

DiagrammeR::grViz("
digraph DAG {
  # Graph settings
  graph [layout=neato, margin=\"0.0, 0.0, 0.0, 0.0\"]  # Increase margins (format: \"top,right,bottom,left\")
  
  # Add a title using a simple label approach
  labelloc=\"t\"
  label=\"Causal Pathways of HIV and Stroke\\nExamining direct and confounded relationships\\n \\n\"      fontname=\"Cabin\"
  fontsize=16
  
  # Node settings
  node [shape=plaintext, fontsize=16, fontname=\"Cabin\"]
  
  # Edge settings
  edge [penwidth=1.50, color=\"darkblue\", arrowsize=1.00]
  
  # Nodes with exact coordinates
  HIV [label=\"HIV\", pos=\"2.5, .5!\", fontcolor=\"dodgerblue\"]
  Stroke [label=\"Stroke\", pos=\"4,.5!\", fontcolor=\"dodgerblue\"]
  Smoking [label=\"Smoking\", pos=\"1,1.5!\"]
  Age [label=\"Age\", pos=\"1,-.5!\"]
  UC [label=\"Unmeasured\\nConfounder\", fontcolor=\"red\", pos=\"3.0,1.5!\"]
  
  # Edges
  HIV -> Stroke
  Smoking -> HIV
  Age -> Smoking
  Age -> HIV
  Age -> Stroke
  UC -> Smoking
  UC -> Stroke
  
  # Caption as a separate node at the bottom
  Caption [shape=plaintext, label=\"Figure 1: Cartoon DAG showing relationship between HIV and stroke with potential confounders.\", 
           fontsize=10, pos=\"2,-1.5!\"]
}
")

```

<br>


## 1. Convert the DAG from DiagrammeR to dagitty

Create dagitty DAG from DiagrammeR DAG and set coordinates to match conceptual understanding,

Shorten "Smoking" to "Smoke" for better fit in nodes.

```{r}

# Create the dagitty object with our causal structure
dag <- dagitty::dagitty("dag {
  HIV -> Stroke
  Smoke -> HIV
  Age -> Smoke
  Age -> HIV
  Age -> Stroke
  UC -> Smoke
  UC -> Stroke
  
  HIV [exposure]
  Stroke [outcome]
}")

# Set coordinates for visualization
dagitty::coordinates(dag) <- list(
  x = base::c(HIV = 2.5, Stroke = 4.0, Smoke = 1.0, Age = 1, UC = 3.0),
  y = base::c(HIV = 2.0, Stroke = 2.0, Smoke = 1.0, Age = 3, UC = 1.0)
)

# Basic plot of the DAG
graphics::plot(dag)

```
<br>

## 2. DAG Analysis Results

```{r}

# Get the implied conditional independencies
independencies <- dagitty::impliedConditionalIndependencies(dag)

# Find all valid adjustment sets
adjustment_sets <- dagitty::adjustmentSets(dag)

# Find minimal sufficient adjustment sets
minimal_adjustment_sets <- dagitty::adjustmentSets(dag, type = "minimal")

# Identify paths between exposure and outcome
hiv_stroke_paths <- dagitty::paths(dag, from = "HIV", to = "Stroke")

# Find instrumental variables
instruments <- tryCatch({
  dagitty::instrumentalVariables(dag, exposure = "HIV", outcome = "Stroke")
}, error = function(e) {
  NULL
})

# Check identifiability of causal effect
is_identifiable <- dagitty::isAcyclic(dag) && 
                   length(dagitty::adjustmentSets(dag)) > 0

# Find ancestors and descendants
hiv_ancestors <- dagitty::ancestors(dag, "HIV")
hiv_descendants <- dagitty::descendants(dag, "HIV")
stroke_ancestors <- dagitty::ancestors(dag, "Stroke")
stroke_descendants <- dagitty::descendants(dag, "Stroke")

# Check backdoor paths
backdoor_paths <- character(0)
paths_data <- tryCatch({
  dagitty::paths(dag, from = "HIV", to = "Stroke")
}, error = function(e) {
  data.frame(paths = character(0), length = numeric(0))
})

if(is.data.frame(paths_data) && nrow(paths_data) > 0) {
  for(i in 1:nrow(paths_data)) {
    path_str <- paths_data$paths[i]
    path_elements <- strsplit(path_str, " ")[[1]]
    
    # A backdoor path has an arrow pointing into the exposure
    if(length(path_elements) >= 3) {
      second_element <- path_elements[2]
      if(second_element == "<-") {
        backdoor_paths <- base::c(backdoor_paths, path_str)
      }
    }
  }
}

# Find directed paths (potential mediation)
directed_paths <- tryCatch({
  dagitty::paths(dag, from = "HIV", to = "Stroke", directed = TRUE)
}, error = function(e) {
  data.frame(paths = character(0), length = numeric(0))
})

mediators <- character(0)
if(is.data.frame(directed_paths) && nrow(directed_paths) > 0) {
  mediators_list <- vector("list", nrow(directed_paths))
  
  for(i in 1:nrow(directed_paths)) {
    path_str <- directed_paths$paths[i]
    path_elements <- strsplit(path_str, " ")[[1]]
    
    # Extract variables (every other element)
    path_vars <- path_elements[seq(1, length(path_elements), by = 2)]
    
    # Variables between HIV and Stroke are mediators
    if(length(path_vars) > 2) {
      potential_mediators <- path_vars[-base::c(1, length(path_vars))]
      mediators <- base::c(mediators, potential_mediators)
    }
  }
  mediators <- unique(mediators)
}

# Test d-separation
d_sep_results <- list(
  Smoke_stroke = dagitty::dseparated(dag, "Smoke", "Stroke", base::c("HIV", "Age", "UC")),
  age_uc = dagitty::dseparated(dag, "Age", "UC", base::c()),
  hiv_uc = dagitty::dseparated(dag, "HIV", "UC", base::c("Age", "Smoke"))
)

# Check paths under different adjustments
adjustment_effects <- list()
adjustment_sets_to_check <- list(
  "None" = base::c(),
  "Age" = base::c("Age"),
  "Age+Smoke" = base::c("Age", "Smoke"),
  "Age+UC" = base::c("Age", "UC")
)

for(adj_name in names(adjustment_sets_to_check)) {
  adj_set <- adjustment_sets_to_check[[adj_name]]
  paths <- tryCatch({
    dagitty::paths(dag, from = "HIV", to = "Stroke")
  }, error = function(e) {
    data.frame(paths = character(0), length = numeric(0))
  })
  
  if(is.data.frame(paths) && nrow(paths) > 0) {
    open_paths <- tryCatch({
      dagitty::paths(dag, from = "HIV", to = "Stroke", Z = adj_set)
    }, error = function(e) {
      data.frame(paths = character(0), length = numeric(0))
    })
    
    adjustment_effects[[adj_name]] <- list(
      "total_paths" = nrow(paths),
      "open_paths" = nrow(open_paths)
    )
  } else {
    adjustment_effects[[adj_name]] <- list(
      "total_paths" = 0,
      "open_paths" = 0
    )
  }
}

# Check impact of unmeasured confounding
unmeasured_impact <- list()
all_vars <- names(dagitty::coordinates(dag)$x)

for(var in all_vars) {
  if(var != "HIV" && var != "Stroke") {
    # Create a DAG where this variable is latent
    dag_modified <- dag
    latent_vars <- dagitty::latents(dag_modified)
    dagitty::latents(dag_modified) <- base::c(latent_vars, var)
    
    # Check adjustment sets
    adj_sets_original <- dagitty::adjustmentSets(dag)
    adj_sets_modified <- dagitty::adjustmentSets(dag_modified)
    
    unmeasured_impact[[var]] <- list(
      "original_sets" = length(adj_sets_original),
      "modified_sets" = length(adj_sets_modified)
    )
  }
}

```
<br>

### 2.1 Key DAG Properties

```{r}

# Safely determine if there are paths
has_paths <- tryCatch({
  paths_data <- dagitty::paths(dag, from = "HIV", to = "Stroke")
  is.data.frame(paths_data) && nrow(paths_data) > 0
}, error = function(e) {
  FALSE
})

num_paths <- if(has_paths) nrow(dagitty::paths(dag, from = "HIV", to = "Stroke")) else 0

properties_df <- data.frame(
  Property = base::c(
    "Acyclic DAG", 
    "Causal effect identifiable",
    "Number of paths from HIV to Stroke",
    "Number of backdoor paths",
    "Direct effect of HIV on Stroke exists",
    "Potential mediators",
    "Number of adjustment sets",
    "Minimal adjustment sets"
  ),
  Value = base::c(
    ifelse(dagitty::isAcyclic(dag), "Yes", "No"),
    ifelse(is_identifiable, "Yes", "No"),
    num_paths,
    length(backdoor_paths),
    ifelse("HIV" %in% dagitty::parents(dag, "Stroke"), "Yes", "No"),
    ifelse(length(mediators) > 0, paste(mediators, collapse=", "), "None"),
    length(adjustment_sets),
    ifelse(length(minimal_adjustment_sets) > 0, 
           paste(sapply(minimal_adjustment_sets, function(x) paste(x, collapse=", ")), collapse="; "), 
           "None")
  )
)

kableExtra::kable(properties_df, caption = "Key Properties of the DAG") %>%
  kableExtra::kable_styling(bootstrap_options = base::c("striped", "hover", "condensed"))

```
<br>

### 2.2 All Paths Between HIV and Stroke

```{r}

# Safely get paths
paths_data <- tryCatch({
  dagitty::paths(dag, from = "HIV", to = "Stroke")
}, error = function(e) {
  data.frame(paths = character(0), length = numeric(0))
})

if(is.data.frame(paths_data) && nrow(paths_data) > 0) {
  paths_df <- data.frame(
    Path = paths_data$paths,
    Length = paths_data$length,
    IsBackdoor = sapply(paths_data$paths, function(p) {
      elements <- strsplit(p, " ")[[1]]
      if(length(elements) >= 3) {
        return(elements[2] == "<-")
      }
      return(FALSE)
    }),
    IsDirected = sapply(paths_data$paths, function(p) {
      elements <- strsplit(p, " ")[[1]]
      all_forward <- TRUE
      for(i in seq(2, length(elements), by=2)) {
        if(elements[i] != "->") {
          all_forward <- FALSE
          break
        }
      }
      return(all_forward)
    })
  )
  
  kableExtra::kable(paths_df, caption = "All Paths Between HIV and Stroke") %>%
    kableExtra::kable_styling(bootstrap_options = base::c("striped", "hover", "condensed"))
} else {
  cat("No paths found between HIV and Stroke")
}


```
<br>

### 2.3 Implied Conditional Independencies

```{r}

if(length(independencies) > 0) {
  # Create a clean format for the independencies
  ind_statements <- character(length(independencies))
  
  for(i in 1:length(independencies)) {
    ind <- independencies[[i]]
    if(length(ind) >= 2) {
      statement <- paste0(ind[1], " _||_ ", ind[2])
      
      if(length(ind) > 2 && length(ind[[3]]) > 0) {
        statement <- paste0(statement, " | ", paste(ind[[3]], collapse=", "))
      } else {
        statement <- paste0(statement, " (unconditionally)")
      }
      
      ind_statements[i] <- statement
    }
  }
  
  independencies_df <- data.frame(
    Statement = ind_statements
  )
  
  kableExtra::kable(independencies_df, caption = "Testable Implications of the DAG") %>%
    kableExtra::kable_styling(bootstrap_options = base::c("striped", "hover", "condensed"))
} else {
  cat("No conditional independencies implied by this DAG")
}


```
<br>

### 2.4 Ancestors and Descendants

```{r}

relations_df <- data.frame(
  Variable = base::c("HIV", "Stroke"),
  Ancestors = base::c(
    paste(dplyr::setdiff(hiv_ancestors, "HIV"), collapse=", "),
    paste(dplyr::setdiff(stroke_ancestors, "Stroke"), collapse=", ")
  ),
  Descendants = c(
    paste(dplyr::setdiff(hiv_descendants, "HIV"), collapse=", "),
    paste(dplyr::setdiff(stroke_descendants, "Stroke"), collapse=", ")
  )
)

kableExtra::kable(relations_df, caption = "Ancestor and Descendant Relationships") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```
<br>

### 2.5 Open Paths Under Different Adjustment Sets

```{r}

adj_effects_df <- data.frame(
  AdjustmentSet = names(adjustment_effects),
  TotalPaths = sapply(adjustment_effects, function(x) x$total_paths),
  OpenPaths = sapply(adjustment_effects, function(x) x$open_paths),
  ClosedPaths = sapply(adjustment_effects, function(x) x$total_paths - x$open_paths)
)

kableExtra::kable(adj_effects_df, caption = "Effect of Different Adjustment Sets on Open Paths") %>%
  kableExtra::kable_styling(bootstrap_options = base::c("striped", "hover", "condensed"))

```
<br>

### 2.6 Impact of Unmeasured Variables

```{r}

unmeasured_df <- data.frame(
  Variable = names(unmeasured_impact),
  OriginalAdjustmentSets = sapply(unmeasured_impact, function(x) x$original_sets),
  AdjustmentSetsIfUnmeasured = sapply(unmeasured_impact, function(x) x$modified_sets),
  IdentifiableIfUnmeasured = sapply(unmeasured_impact, function(x) x$modified_sets > 0)
)

kableExtra::kable(unmeasured_df, caption = "Impact of Each Variable Being Unmeasured") %>%
  kableExtra::kable_styling(bootstrap_options = base::c("striped", "hover", "condensed"))

```
<br>

### 2.7 D-Separation Tests

```{r}

d_sep_df <- data.frame(
  Test = base::c(
    "Smoke _||_ Stroke | HIV, Age, UC",
    "Age _||_ UC (unconditional)",
    "HIV _||_ UC | Age, Smoke"
  ),
  Result = c(
    ifelse(d_sep_results$Smoke_stroke, "Yes (d-separated)", "No (d-connected)"),
    ifelse(d_sep_results$age_uc, "Yes (d-separated)", "No (d-connected)"),
    ifelse(d_sep_results$hiv_uc, "Yes (d-separated)", "No (d-connected)")
  )
)

kableExtra::kable(d_sep_df, caption = "D-Separation Tests") %>%
  kableExtra::kable_styling(bootstrap_options = base::c("striped", "hover", "condensed"))

```
<br>

### 3. Visualizing with ggdag

For more visually appealing DAG visualizations:

```{r}

# Create dagitty object again with ggdag positioning
dag <- dagitty::dagitty("dag {
  HIV -> Stroke
  Smoke -> HIV
  Age -> Smoke
  Age -> HIV
  Age -> Stroke
  UC -> Smoke
  UC -> Stroke
  
  HIV [exposure]
  Stroke [outcome]
}")

# Set coordinates in dagitty format
dagitty::coordinates(dag) <- list(
  x = base::c(HIV = 2.5, Stroke = 4.0, Smoke = 1.0, Age = 1, UC = 3.0),
  y = base::c(HIV = 2.0, Stroke = 2.0, Smoke = 3.0, Age = 1, UC = 3.0)
)

# Convert to ggdag format
dag_tidy <- ggdag::tidy_dagitty(dag)


# Status plot showing exposure/outcome
ggdag::ggdag_status(dag_tidy) +
  ggdag::theme_dag() +
  ggdag::label("Status Plot: Exposure and Outcome")

# Adjustment set visualization
ggdag::ggdag_adjustment_set(dag_tidy) +
  ggdag::theme_dag() +
  ggdag::label("Adjustment Sets for HIV â†’ Stroke")

# Paths visualization
ggdag::ggdag_paths(dag_tidy) +
  ggdag::theme_dag() +
  ggdag::label("All Paths between HIV and Stroke")

```
<br>

## 4. Summary of Findings

Based on our DAG analysis, we can conclude:

1. The causal effect of HIV on Stroke is identifiable through proper adjustment
1. There is a direct path from HIV to Stroke, suggesting a potential direct causal effect
1. There are also indirect paths through mediators, suggesting multiple causal mechanisms
1. Age and UC (Unmeasured Confounder) are important confounders in this relationship
1. If UC remains unmeasured, we can still identify the causal effect by adjusting for Age
1. This DAG framework provides guidance for empirical analysis once data becomes available

This structured analysis illustrates how causal diagrams can help identify proper adjustment strategies for estimating causal effects, even before data collection begins.
